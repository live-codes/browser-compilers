// Generated by dts-bundle v0.7.3

declare module '@stencil/core' {
    export type {
        ChildNode,
        ComponentOptions,
        ComponentDidLoad,
        ComponentDidUpdate,
        ComponentInterface,
        ComponentWillLoad,
        ComponentWillUpdate,
        EventEmitter,
        EventOptions,
        FunctionalComponent,
        FunctionalUtilities,
        JSX,
        MethodOptions,
        ModeStyles,
        ListenOptions,
        ListenTargetOptions,
        PropOptions,
        QueueApi,
        RafCallback,
        VNode,
        VNodeData,
    } from '@stencil/core/stencil-public-runtime';
    
    export {
        Build,
        Component,
        Element,
        Event,
        getAssetPath,
        getElement,
        getMode,
        getRenderingRef,
        Fragment,
        forceUpdate,
        h,
        Host,
        Env,
        Listen,
        Method,
        Prop,
        readTask,
        setAssetPath,
        setMode,
        State,
        Watch,
        writeTask,
        setErrorHandler,
    } from '@stencil/core/stencil-public-runtime';
    
    export type { StencilConfig as Config, PrerenderConfig } from '@stencil/core/stencil-public-compiler';
}

declare module '@stencil/core/stencil-public-compiler' {
    import type { JsonDocs } from '@stencil/core/stencil-public-docs';
    import type { PrerenderUrlResults } from '@stencil/core/';
    export * from '@stencil/core/stencil-public-docs';
    /**
        * https://stenciljs.com/docs/config/
        */
    export interface StencilConfig {
            /**
                * By default, Stencil will attempt to optimize small scripts by inlining them in HTML. Setting
                * this flag to `false` will prevent this optimization and keep all scripts separate from HTML.
                */
            allowInlineScripts?: boolean;
            /**
                * By setting `autoprefixCss` to `true`, Stencil will use the appropriate config to automatically
                * prefix css. For example, developers can write modern and standard css properties, such as
                * "transform", and Stencil will automatically add in the prefixed version, such as "-webkit-transform".
                * As of Stencil v2, autoprefixing CSS is no longer the default.
                * Defaults to `false`
                */
            autoprefixCss?: boolean | any;
            /**
                * By default, Stencil will statically analyze the application and generate a component graph of
                * how all the components are interconnected.
                *
                * From the component graph it is able to best decide how components should be grouped
                * depending on their usage with one another within the app.
                * By doing so it's able to bundle components together in order to reduce network requests.
                * However, bundles can be manually generated using the bundles config.
                *
                * The bundles config is an array of objects that represent how components are grouped together
                * in lazy-loaded bundles.
                * This config is rarely needed as Stencil handles this automatically behind the scenes.
                */
            bundles?: ConfigBundle[];
            /**
                * Stencil will cache build results in order to speed up rebuilds.
                * To disable this feature, set enableCache to false.
                */
            enableCache?: boolean;
            /**
                * Stencil is traditionally used to compile many components into an app,
                * and each component comes with its own compartmentalized styles.
                * However, it's still common to have styles which should be "global" across all components and the website.
                * A global CSS file is often useful to set CSS Variables.
                *
                * Additonally, the globalStyle config is can be used to precompile styles with Sass, PostCss, etc.
                * Below is an example folder structure containing a webapp's global sass file, named app.css.
                */
            globalStyle?: string;
            /**
                * When the hashFileNames config is set to true, and it is a production build,
                * the hashedFileNameLength config is used to determine how many characters the file name's hash should be.
                */
            hashedFileNameLength?: number;
            /**
                * During production builds, the content of each generated file is hashed to represent the content,
                * and the hashed value is used as the filename. If the content isn't updated between builds,
                * then it receives the same filename. When the content is updated, then the filename is different.
                *
                * By doing this, deployed apps can "forever-cache" the build directory and take full advantage of
                * content delivery networks (CDNs) and heavily caching files for faster apps.
                */
            hashFileNames?: boolean;
            /**
                * The namespace config is a string representing a namespace for the app.
                * For apps that are not meant to be a library of reusable components,
                * the default of App is just fine. However, if the app is meant to be consumed
                * as a third-party library, such as Ionic, a unique namespace is required.
                */
            namespace?: string;
            /**
                * Stencil is able to take an app's source and compile it to numerous targets,
                * such as an app to be deployed on an http server, or as a third-party library
                * to be distributed on npm. By default, Stencil apps have an output target type of www.
                *
                * The outputTargets config is an array of objects, with types of www and dist.
                */
            outputTargets?: OutputTarget[];
            /**
                * The plugins config can be used to add your own rollup plugins.
                * By default, Stencil does not come with Sass or PostCss support.
                * However, either can be added using the plugin array.
                */
            plugins?: any[];
            /**
                * The srcDir config specifies the directory which should contain the source typescript files
                * for each component. The standard for Stencil apps is to use src, which is the default.
                */
            srcDir?: string;
            /**
                * Passes custom configuration down to the "@rollup/plugin-commonjs" that Stencil uses under the hood.
                * For further information: https://stenciljs.com/docs/module-bundling
                */
            commonjs?: BundlingConfig;
            /**
                * Passes custom configuration down to the "@rollup/plugin-node-resolve" that Stencil uses under the hood.
                * For further information: https://stenciljs.com/docs/module-bundling
                */
            nodeResolve?: NodeResolveConfig;
            /**
                * Passes custom configuration down to rollup itself, not all rollup options can be overriden.
                */
            rollupConfig?: RollupConfig;
            /**
                * Sets if the ES5 build should be generated or not. Stencil generates a modern build without ES5,
                * whereas this setting to `true` will also create es5 builds for both dev and prod modes. Setting
                * `buildEs5` to `prod` will only build ES5 in prod mode. Basically if the app does not need to run
                * on legacy browsers (IE11 and Edge 18 and below), it's safe to not build ES5, which will also speed
                * up build times. Defaults to `false`.
                */
            buildEs5?: boolean | 'prod';
            /**
                * Sets if the JS browser files are minified or not. Stencil uses `terser` under the hood.
                * Defaults to `false` in dev mode and `true` in production mode.
                */
            minifyJs?: boolean;
            /**
                * Sets if the CSS is minified or not.
                * Defaults to `false` in dev mode and `true` in production mode.
                */
            minifyCss?: boolean;
            /**
                * Forces Stencil to run in `dev` mode if the value is `true` and `production` mode
                * if it's `false`.
                *
                * Defaults to `false` (ie. production) unless the `--dev` flag is used in the CLI.
                */
            devMode?: boolean;
            /**
                * Object to provide a custom logger. By default a `logger` is already provided for the
                * platform the compiler is running on, such as NodeJS or a browser.
                */
            logger?: Logger;
            /**
                * Config to add extra runtime for DOM features that require more polyfills. Note
                * that not all DOM APIs are fully polyfilled when using the slot polyfill. These
                * are opt-in since not all users will require the additional runtime.
                */
            extras?: ConfigExtras;
            /**
                * The hydrated flag identifies if a component and all of its child components
                * have finished hydrating. This helps prevent any flash of unstyled content (FOUC)
                * as various components are asynchronously downloaded and rendered. By default it
                * will add the `hydrated` CSS class to the element. The `hydratedFlag` confg can be used
                * to change the name of the CSS class, change it to an attribute, or change which
                * type of CSS properties and values are assigned before and after hydrating. This config
                * can also be used to not include the hydrated flag at all by setting it to `null`.
                */
            hydratedFlag?: HydratedFlag;
            /**
                * Sets the task queue used by stencil's runtime. The task queue schedules DOM read and writes
                * across the frames to efficiently render and reduce layout thrashing. By default,
                * `async` is used. It's recommended to also try each setting to decide which works
                * best for your use-case. In all cases, if your app has many CPU intensive tasks causing the
                * main thread to periodically lock-up, it's always recommended to try
                * [Web Workers](https://stenciljs.com/docs/web-workers) for those tasks.
                *
                * - `async`: DOM read and writes are scheduled in the next frame to prevent layout thrashing.
                *   During intensive CPU tasks it will not reschedule rendering to happen in the next frame.
                *   `async` is ideal for most apps, and if the app has many intensive tasks causing the main
                *   thread to lock-up, it's recommended to try [Web Workers](https://stenciljs.com/docs/web-workers)
                *   rather than the congestion async queue.
                *
                * - `congestionAsync`: DOM reads and writes are scheduled in the next frame to prevent layout
                *   thrashing. When the app is heavily tasked and the queue becomes congested it will then
                *   split the work across multiple frames to prevent blocking the main thread. However, it can
                *   also introduce unnecesary reflows in some cases, especially during startup. `congestionAsync`
                *   is ideal for apps running animations while also simultaniously executing intesive tasks
                *   which may lock-up the main thread.
                *
                * - `immediate`: Makes writeTask() and readTask() callbacks to be executed syncronously. Tasks
                *   are not scheduled to run in the next frame, but do note there is at least one microtask.
                *   The `immediate` setting is ideal for apps that do not provide long running and smooth
                *   animations. Like the async setting, if the app has intensive tasks causing the main thread
                *   to lock-up, it's recommended to try [Web Workers](https://stenciljs.com/docs/web-workers).
                */
            taskQueue?: 'async' | 'immediate' | 'congestionAsync';
            /**
                * Provide a object of key/values accessible within the app, using the `Env` object.
                */
            env?: {
                    [prop: string]: string | undefined;
            };
            globalScript?: string;
            srcIndexHtml?: string;
            watch?: boolean;
            testing?: TestingConfig;
            maxConcurrentWorkers?: number;
            preamble?: string;
            rollupPlugins?: {
                    before?: any[];
                    after?: any[];
            };
            entryComponentsHint?: string[];
            buildDist?: boolean;
            buildLogFilePath?: string;
            cacheDir?: string;
            devInspector?: boolean;
            devServer?: StencilDevServerConfig;
            enableCacheStats?: boolean;
            sys?: CompilerSystem;
            tsconfig?: string;
            validateTypes?: boolean;
            /**
                * An array of RegExp patterns that are matched against all source files before adding
                * to the watch list in watch mode. If the file path matches any of the patterns, when it
                * is updated, it will not trigger a re-run of tests.
                */
            watchIgnoredRegex?: RegExp | RegExp[];
            excludeUnusedDependencies?: boolean;
            stencilCoreResolvedId?: string;
    }
    export interface ConfigExtras {
            /**
                * By default, the slot polyfill does not update `appendChild()` so that it appends
                * new child nodes into the correct child slot like how shadow dom works. This is an opt-in
                * polyfill for those who need it when using `element.appendChild(node)` and expecting the
                * child to be appended in the same location shadom dom would. This is not required for
                * IE11 or Edge 18, but can be enabled if the app is using `appendChild()`. Defaults to `false`.
                */
            appendChildSlotFix?: boolean;
            /**
                * By default, the runtime does not polyfill `cloneNode()` when cloning a component
                * that uses the slot polyfill. This is an opt-in polyfill for those who need it.
                * This is not required for IE11 or Edge 18, but can be enabled if the app is using
                * `cloneNode()` and unexpected node are being cloned due to the slot polyfill
                * simulating shadow dom. Defaults to `false`.
                */
            cloneNodeFix?: boolean;
            /**
                * Include the CSS Custom Property polyfill/shim for legacy browsers. ESM builds will
                * not include the css vars shim. Defaults to `false`
                */
            cssVarsShim?: boolean;
            /**
                * Dynamic `import()` shim. This is only needed for Edge 18 and below, and Firefox 67
                * and below. Defaults to `false`.
                */
            dynamicImportShim?: boolean;
            /**
                * Dispatches component lifecycle events. Mainly used for testing. Defaults to `false`.
                */
            lifecycleDOMEvents?: boolean;
            /**
                * Safari 10 supports ES modules with `<script type="module">`, however, it did not implement
                * `<script nomodule>`. When set to `true`, the runtime will patch support for Safari 10
                * due to its lack of `nomodule` support.
                * Defaults to `false`.
                */
            safari10?: boolean;
            /**
                * It is possible to assign data to the actual `<script>` element's `data-opts` property,
                * which then gets passed to Stencil's initial bootstrap. This feature is only required
                * for very special cases and rarely needed. Defaults to `false`.
                */
            scriptDataOpts?: boolean;
            /**
                * If enabled `true`, the runtime will check if the shadow dom shim is required. However,
                * if it's determined that shadow dom is already natively supported by the browser then
                * it does not request the shim. When set to `false` it will avoid all shadow dom tests.
                * Defaults to `false`.
                */
            shadowDomShim?: boolean;
            /**
                * When a component is first attached to the DOM, this setting will wait a single tick before
                * rendering. This worksaround an Angular issue, where Angular attaches the elements before
                * settings their initial state, leading to double renders and unnecesary event dispatchs.
                * Defaults to `false`.
                */
            initializeNextTick?: boolean;
            /**
                * For browsers that do not support shadow dom (IE11 and Edge 18 and below), slot is polyfilled
                * to simulate the same behavior. However, the host element's `childNodes` and `children`
                * getters are not patched to only show the child nodes and elements of the default slot.
                * Defaults to `false`.
                */
            slotChildNodesFix?: boolean;
            /**
                * Enables the tagNameTransform option of `defineCustomElements()`, so the component tagName
                * can be customized at runtime. Defaults to `false`.
                */
            tagNameTransform?: boolean;
    }
    export interface Config extends StencilConfig {
            buildAppCore?: boolean;
            buildDocs?: boolean;
            configPath?: string;
            writeLog?: boolean;
            devServer?: DevServerConfig;
            flags?: ConfigFlags;
            fsNamespace?: string;
            logLevel?: LogLevel;
            rootDir?: string;
            packageJsonFilePath?: string;
            sourceMap?: boolean;
            suppressLogs?: boolean;
            profile?: boolean;
            tsCompilerOptions?: any;
            _isValidated?: boolean;
            _isTesting?: boolean;
    }
    export interface HydratedFlag {
            /**
                * Defaults to `hydrated`.
                */
            name?: string;
            /**
                * Can be either `class` or `attribute`. Defaults to `class`.
                */
            selector?: 'class' | 'attribute';
            /**
                * The CSS property used to show and hide components. Defaults to use the CSS `visibility`
                * property. Other commonly used CSS properties would be `display` with the `initialValue`
                * setting as `none`, or `opacity` with the `initialValue` as `0`. Defaults to `visibility`
                * and the default `initialValue` is `hidden`.
                */
            property?: string;
            /**
                * This is the CSS value to give all components before it has been hydrated.
                * Defaults to `hidden`.
                */
            initialValue?: string;
            /**
                * This is the CSS value to assign once a component has finished hydrating.
                * This is the CSS value that'll allow the component to show. Defaults to `inherit`.
                */
            hydratedValue?: string;
    }
    export interface StencilDevServerConfig {
            /**
                * IP address used by the dev server. The default is `0.0.0.0`, which points to all IPv4 addresses
                * on the local machine, such as `localhost`.
                */
            address?: string;
            /**
                * Base path to be used by the server. Defaults to the root pathname.
                */
            basePath?: string;
            /**
                * EXPERIMENTAL!
                * During development, node modules can be independently requested and bundled, making for
                * faster build times. This is only available using the Stencil Dev Server throughout
                * development. Production builds and builds with the `es5` flag will override
                * this setting to `false`. Default is `false`.
                */
            experimentalDevModules?: boolean;
            /**
                * If the dev server should respond with gzip compressed content. Defaults to `true`.
                */
            gzip?: boolean;
            /**
                * When set, the dev server will run via https using the SSL certificate and key you provide
                * (use `fs` if you want to read them from files).
                */
            https?: Credentials;
            /**
                * The URL the dev server should first open to. Defaults to `/`.
                */
            initialLoadUrl?: string;
            /**
                * When `true`, every request to the server will be logged within the terminal.
                * Defaults to `false`.
                */
            logRequests?: boolean;
            /**
                * By default, when dev server is started the local dev URL is opened in your default browser.
                * However, to prevent this URL to be opened change this value to `false`. Defaults to `true`.
                */
            openBrowser?: boolean;
            /**
                * Sets the server's port. Defaults to `3333`.
                */
            port?: number;
            /**
                * When files are watched and updated, by default the dev server will use `hmr` (Hot Module Replacement)
                * to update the page without a full page refresh. To have the page do a full refresh use `pageReload`.
                * To disable any reloading, use `null`. Defaults to `hmr`.
                */
            reloadStrategy?: PageReloadStrategy;
            /**
                * Local path to a NodeJs file with a dev server request listener as the default export.
                * The user's request listener is given the first chance to handle every request the dev server
                * receives, and can choose to handle it or instead pass it on to the default dev server
                * by calling `next()`.
                *
                * Below is an example of a NodeJs file the `requestListenerPath` config is using.
                * The request and response arguments are the same as Node's `http` module and `RequestListener`
                * callback. https://nodejs.org/api/http.html#http_http_createserver_options_requestlistener
                *
                * ```js
                * module.exports = function (req, res, next) {
                *    if (req.url === '/ping') {
                *      // custom response overriding the dev server
                *      res.setHeader('Content-Type', 'text/plain');
                *      res.writeHead(200);
                *      res.end('pong');
                *    } else {
                *      // pass request on to the default dev server
                *      next();
                *    }
                * };
                * ```
                */
            requestListenerPath?: string;
            /**
                * The root directory to serve the files from.
                */
            root?: string;
            /**
                * If the dev server should Server-Side Render (SSR) each page, meaning it'll dynamically generate
                * server-side rendered html on each page load. The `--ssr` flag will most commonly be used with
                * the`--dev --watch --serve` flags during development. Note that this is for development purposes
                * only, and the built-in dev server should not be used for production. Defaults to `false`.
                */
            ssr?: boolean;
            /**
                * If the dev server fails to start up within the given timout (in milliseconds), the startup will
                * be canceled. Set to zero to disable the timeout. Defaults to `15000`.
                */
            startupTimeout?: number;
            /**
                * Whether to use the dev server's websocket client or not. Defaults to `true`.
                */
            websocket?: boolean;
            /**
                * If the dev server should fork a worker for the server process or not. A singled-threaded dev server
                * is slower, however it is useful for debugging http requests and responses. Defaults to `true`.
                */
            worker?: boolean;
    }
    export interface DevServerConfig extends StencilDevServerConfig {
            browserUrl?: string;
            devServerDir?: string;
            excludeHmr?: string[];
            historyApiFallback?: HistoryApiFallback;
            openBrowser?: boolean;
            prerenderConfig?: string;
            protocol?: 'http' | 'https';
            srcIndexHtml?: string;
    }
    export interface HistoryApiFallback {
            index?: string;
            disableDotRule?: boolean;
    }
    export interface DevServerEditor {
            id: string;
            name?: string;
            supported?: boolean;
            priority?: number;
    }
    export interface ConfigFlags {
            task?: TaskCommand;
            args?: string[];
            knownArgs?: string[];
            unknownArgs?: string[];
            address?: string;
            build?: boolean;
            cache?: boolean;
            checkVersion?: boolean;
            ci?: boolean;
            compare?: boolean;
            config?: string;
            debug?: boolean;
            dev?: boolean;
            docs?: boolean;
            docsApi?: string;
            docsJson?: string;
            e2e?: boolean;
            emulate?: string;
            es5?: boolean;
            headless?: boolean;
            help?: boolean;
            log?: boolean;
            logLevel?: string;
            verbose?: boolean;
            maxWorkers?: number;
            open?: boolean;
            port?: number;
            prerender?: boolean;
            prod?: boolean;
            profile?: boolean;
            root?: string;
            screenshot?: boolean;
            screenshotConnector?: string;
            serve?: boolean;
            serviceWorker?: boolean;
            spec?: boolean;
            ssr?: boolean;
            stats?: boolean;
            updateScreenshot?: boolean;
            version?: boolean;
            watch?: boolean;
            devtools?: boolean;
    }
    export type TaskCommand = 'build' | 'docs' | 'generate' | 'g' | 'help' | 'info' | 'prerender' | 'serve' | 'test' | 'version';
    export type PageReloadStrategy = 'hmr' | 'pageReload' | null;
    /**
        * The prerender config is used when prerendering a `www` output target.
        * Within `stencil.config.ts`, set the path to the prerendering
        * config file path using the `prerenderConfig` property, such as:
        *
        * ```tsx
        * import { Config } from '@stencil/core';
        * export const config: Config = {
        *   outputTargets: [
        *     {
        *       type: 'www',
        *       baseUrl: 'https://stenciljs.com/',
        *       prerenderConfig: './prerender.config.ts',
        *     }
        *   ]
        * };
        * ```
        *
        * The `prerender.config.ts` should export a `config` object using
        * the `PrerenderConfig` interface.
        *
        * ```tsx
        * import { PrerenderConfig } from '@stencil/core';
        * export const config: PrerenderConfig = {
        *   ...
        * };
        * ```
        *
        * For more info: https://stenciljs.com/docs/static-site-generation
        */
    export interface PrerenderConfig {
            /**
                * Run after each `document` is hydrated, but before it is serialized
                * into an HTML string. Hook is passed the `document` and its `URL`.
                */
            afterHydrate?(document: Document, url: URL, results: PrerenderUrlResults): any | Promise<any>;
            /**
                * Run before each `document` is hydrated. Hook is passed the `document` it's `URL`.
                */
            beforeHydrate?(document: Document, url: URL): any | Promise<any>;
            /**
                * Runs after the template Document object has serialize into an
                * HTML formatted string. Returns an HTML string to be used as the
                * base template for all prerendered pages.
                */
            afterSerializeTemplate?(html: string): string | Promise<string>;
            /**
                * Runs before the template Document object is serialize into an
                * HTML formatted string. Returns the Document to be serialized which
                * will become the base template html for all prerendered pages.
                */
            beforeSerializeTemplate?(document: Document): Document | Promise<Document>;
            /**
                * A hook to be used to generate the canonical `<link>` tag
                * which goes in the `<head>` of every prerendered page. Returning `null`
                * will not add a canonical url tag to the page.
                */
            canonicalUrl?(url: URL): string | null;
            /**
                * While prerendering, crawl same-origin URLs found within `<a href>` elements.
                * Defaults to `true`.
                */
            crawlUrls?: boolean;
            /**
                * URLs to start the prerendering from. By default the root URL of `/` is used.
                */
            entryUrls?: string[];
            /**
                * Return `true` the given `<a>` element should be crawled or not.
                */
            filterAnchor?(attrs: {
                    [attrName: string]: string;
            }, base?: URL): boolean;
            /**
                * Return `true` if the given URL should be prerendered or not.
                */
            filterUrl?(url: URL, base: URL): boolean;
            /**
                * Returns the file path which the prerendered HTML content
                * should be written to.
                */
            filePath?(url: URL, filePath: string): string;
            /**
                * Returns the hydrate options to use for each individual prerendered page.
                */
            hydrateOptions?(url: URL): PrerenderHydrateOptions;
            /**
                * Returns the template file's content. The template is the base
                * HTML used for all prerendered pages.
                */
            loadTemplate?(filePath: string): string | Promise<string>;
            /**
                * Used to normalize the page's URL from a given a string and the current
                * page's base URL. Largely used when reading an anchor's `href` attribute
                * value and normalizing it into a `URL`.
                */
            normalizeUrl?(href: string, base: URL): URL;
            robotsTxt?(opts: RobotsTxtOpts): string | RobotsTxtResults;
            sitemapXml?(opts: SitemapXmpOpts): string | SitemapXmpResults;
            /**
                * Static Site Generated (SSG). Does not include Stencil's clientside
                * JavaScript, custom elements or preload modules.
                */
            staticSite?: boolean;
            /**
                * If the prerenndered URLs should have a trailing "/"" or not. Defaults to `false`.
                */
            trailingSlash?: boolean;
    }
    export interface HydrateDocumentOptions {
            /**
                * Build ID that will be added to `<html data-stencil-build="BUILD_ID">`. By default
                * a random ID will be generated
                */
            buildId?: string;
            /**
                * Sets the `href` attribute on the `<link rel="canonical">`
                * tag within the `<head>`. If the value is not defined it will
                * ensure a canonical link tag is no included in the `<head>`.
                */
            canonicalUrl?: string;
            /**
                * Include the HTML comments and attributes used by the clientside
                * JavaScript to read the structure of the HTML and rebuild each
                * component. Defaults to `true`.
                */
            clientHydrateAnnotations?: boolean;
            /**
                * Constrain `setTimeout()` to 1ms, but still async. Also
                * only allows `setInterval()` to fire once, also constrained to 1ms.
                * Defaults to `true`.
                */
            constrainTimeouts?: boolean;
            /**
                * Sets `document.cookie`
                */
            cookie?: string;
            /**
                * Sets the `dir` attribute on the top level `<html>`.
                */
            direction?: string;
            /**
                * Component tag names listed here will not be prerendered, nor will
                * hydrated on the clientside. Components listed here will be ignored
                * as custom elements and treated no differently than a `<div>`.
                */
            excludeComponents?: string[];
            /**
                * Sets the `lang` attribute on the top level `<html>`.
                */
            language?: string;
            /**
                * Maximum number of components to hydrate on one page. Defaults to `300`.
                */
            maxHydrateCount?: number;
            /**
                * Sets `document.referrer`
                */
            referrer?: string;
            /**
                * Removes every `<script>` element found in the `document`. Defaults to `false`.
                */
            removeScripts?: boolean;
            /**
                * Removes CSS not used by elements within the `document`. Defaults to `true`.
                */
            removeUnusedStyles?: boolean;
            /**
                * The url the runtime uses for the resources, such as the assets directory.
                */
            resourcesUrl?: string;
            /**
                * Prints out runtime console logs to the NodeJS process. Defaults to `false`.
                */
            runtimeLogging?: boolean;
            /**
                * Component tags listed here will only be prerendered or serverside-rendered
                * and will not be clientside hydrated. This is useful for components that
                * are not dynamic and do not need to be defined as a custom element within the
                * browser. For example, a header or footer component would be a good example that
                * may not require any clientside JavaScript.
                */
            staticComponents?: string[];
            /**
                * The amount of milliseconds to wait for a page to finish rendering until
                * a timeout error is thrown. Defaults to `15000`.
                */
            timeout?: number;
            /**
                * Sets `document.title`.
                */
            title?: string;
            /**
                * Sets `location.href`
                */
            url?: string;
            /**
                * Sets `navigator.userAgent`
                */
            userAgent?: string;
    }
    export interface SerializeDocumentOptions extends HydrateDocumentOptions {
            /**
                * Runs after the `document` has been hydrated.
                */
            afterHydrate?(document: any): any | Promise<any>;
            /**
                * Sets an approximate line width the HTML should attempt to stay within.
                * Note that this is "approximate", in that HTML may often not be able
                * to be split at an exact line width. Additionally, new lines created
                * is where HTML naturally already has whitespce, such as before an
                * attribute or spaces between words. Defaults to `100`.
                */
            approximateLineWidth?: number;
            /**
                * Runs before the `document` has been hydrated.
                */
            beforeHydrate?(document: any): any | Promise<any>;
            /**
                * Format the HTML in a nicely indented format.
                * Defaults to `false`.
                */
            prettyHtml?: boolean;
            /**
                * Remove quotes from attribute values when possible.
                * Defaults to `true`.
                */
            removeAttributeQuotes?: boolean;
            /**
                * Remove the `=""` from standardized `boolean` attributes,
                * such as `hidden` or `checked`. Defaults to `true`.
                */
            removeBooleanAttributeQuotes?: boolean;
            /**
                * Remove these standardized attributes when their value is empty:
                * `class`, `dir`, `id`, `lang`, and `name`, `title`. Defaults to `true`.
                */
            removeEmptyAttributes?: boolean;
            /**
                * Remove HTML comments. Defaults to `true`.
                */
            removeHtmlComments?: boolean;
    }
    export interface HydrateFactoryOptions extends SerializeDocumentOptions {
            serializeToHtml: boolean;
            destroyWindow: boolean;
            destroyDocument: boolean;
    }
    export interface PrerenderHydrateOptions extends SerializeDocumentOptions {
            /**
                * Adds `<link rel="modulepreload">` for modules that will eventually be requested.
                * Defaults to `true`.
                */
            addModulePreloads?: boolean;
            /**
                * Hash the content of assets, such as images, fonts and css files,
                * and add the hashed value as `v` querystring. For example,
                * `/assets/image.png?v=abcd1234`. This allows for assets to be
                * heavily cached by setting the server's response header with
                * `Cache-Control: max-age=31536000, immutable`.
                */
            hashAssets?: 'querystring';
            /**
                * External stylesheets from `<link rel="stylesheet">` are instead inlined
                * into `<style>` elements. Defaults to `false`.
                */
            inlineExternalStyleSheets?: boolean;
            /**
                * Minify CSS content within `<style>` elements. Defaults to `true`.
                */
            minifyStyleElements?: boolean;
            /**
                * Minify JavaScript content within `<script>` elements. Defaults to `true`.
                */
            minifyScriptElements?: boolean;
            /**
                * Entire `document` should be static. This is useful for specific pages that
                * should be static, rather than the entire site. If the whole site should be static,
                * use the `staticSite` property on the prerender config instead. If only certain
                * components should be static then use `staticComponents` instead.
                */
            staticDocument?: boolean;
    }
    export interface RobotsTxtOpts {
            urls: string[];
            sitemapUrl: string;
            baseUrl: string;
            dir: string;
    }
    export interface RobotsTxtResults {
            content: string;
            filePath: string;
            url: string;
    }
    export interface SitemapXmpOpts {
            urls: string[];
            baseUrl: string;
            dir: string;
    }
    export interface SitemapXmpResults {
            content: string;
            filePath: string;
            url: string;
    }
    /**
        * Common system used by the compiler. All file reads, writes, access, etc. will all use
        * this system. Additionally, throughout each build, the compiler will use an internal
        * in-memory file system as to prevent unnecessary fs reads and writes. At the end of each
        * build all actions the in-memory fs performed will be written to disk using this system.
        * A NodeJS based system will use APIs such as `fs` and `crypto`, and a web-based system
        * will use in-memory Maps and browser APIs. Either way, the compiler itself is unaware
        * of the actual platform it's being ran ontop of.
        */
    export interface CompilerSystem {
            name: 'deno' | 'node' | 'in-memory';
            version: string;
            events?: BuildEvents;
            details?: SystemDetails;
            /**
                * Add a callback which will be ran when destroy() is called.
                */
            addDestory(cb: () => void): void;
            /**
                * Always returns a boolean, does not throw.
                */
            access(p: string): Promise<boolean>;
            /**
                * SYNC! Always returns a boolean, does not throw.
                */
            accessSync(p: string): boolean;
            applyGlobalPatch?(fromDir: string): Promise<void>;
            applyPrerenderGlobalPatch?(opts: {
                    devServerHostUrl: string;
                    window: any;
            }): void;
            cacheStorage?: CacheStorage;
            checkVersion?: (logger: Logger, currentVersion: string) => Promise<() => void>;
            copy?(copyTasks: Required<CopyTask>[], srcDir: string): Promise<CopyResults>;
            /**
                * Always returns a boolean if the files were copied or not. Does not throw.
                */
            copyFile(src: string, dst: string): Promise<boolean>;
            /**
                * Used to destroy any listeners, file watchers or child processes.
                */
            destroy(): Promise<void>;
            /**
                * Does not throw.
                */
            createDir(p: string, opts?: CompilerSystemCreateDirectoryOptions): Promise<CompilerSystemCreateDirectoryResults>;
            /**
                * SYNC! Does not throw.
                */
            createDirSync(p: string, opts?: CompilerSystemCreateDirectoryOptions): CompilerSystemCreateDirectoryResults;
            /**
                * Each plaform as a different way to dynamically import modules.
                */
            dynamicImport?(p: string): Promise<any>;
            /**
                * Creates the worker controller for the current system.
                */
            createWorkerController?(maxConcurrentWorkers: number): WorkerMainController;
            encodeToBase64(str: string): string;
            ensureDependencies?(opts: {
                    rootDir: string;
                    logger: Logger;
                    dependencies: CompilerDependency[];
            }): Promise<{
                    stencilPath: string;
                    diagnostics: Diagnostic[];
            }>;
            ensureResources?(opts: {
                    rootDir: string;
                    logger: Logger;
                    dependencies: CompilerDependency[];
            }): Promise<void>;
            /**
                * process.exit()
                */
            exit(exitCode: number): Promise<void>;
            /**
                * Optionally provide a fetch() function rather than using the built-in fetch().
                * First arg is a url string or Request object (RequestInfo).
                * Second arg is the RequestInit. Returns the Response object
                */
            fetch?(input: string | any, init?: any): Promise<any>;
            /**
                * Generates a sha1 digest encoded as HEX
                */
            generateContentHash?(content: string | any, length?: number): Promise<string>;
            /**
                * Generates a sha1 digest encoded as HEX from a file path
                */
            generateFileHash?(filePath: string | any, length?: number): Promise<string>;
            /**
                * Get the current directory.
                */
            getCurrentDirectory(): string;
            /**
                * The compiler's executing path.
                */
            getCompilerExecutingPath(): string;
            /**
                * The dev server's executing path.
                */
            getDevServerExecutingPath?(): string;
            getEnvironmentVar?(key: string): string;
            /**
                * Gets the absolute file path when for a dependency module.
                */
            getLocalModulePath(opts: {
                    rootDir: string;
                    moduleId: string;
                    path: string;
            }): string;
            /**
                * Gets the full url when requesting a dependency module to fetch from a CDN.
                */
            getRemoteModuleUrl(opts: {
                    moduleId: string;
                    path?: string;
                    version?: string;
            }): string;
            /**
                * Aync glob task. Only available in NodeJS compiler system.
                */
            glob?(pattern: string, options: {
                    cwd?: string;
                    nodir?: boolean;
                    [key: string]: any;
            }): Promise<string[]>;
            /**
                * The number of logical processors available to run threads on the user's computer (cpus).
                */
            hardwareConcurrency: number;
            /**
                * Tests if the path is a symbolic link or not. Always resolves a boolean. Does not throw.
                */
            isSymbolicLink(p: string): Promise<boolean>;
            lazyRequire?: LazyRequire;
            nextTick(cb: () => void): void;
            /**
                * Normalize file system path.
                */
            normalizePath(p: string): string;
            onProcessInterrupt?(cb: () => void): void;
            platformPath: PlatformPath;
            /**
                * All return paths are full normalized paths, not just the basenames. Always returns an array, does not throw.
                */
            readDir(p: string): Promise<string[]>;
            /**
                * SYNC! All return paths are full normalized paths, not just the basenames. Always returns an array, does not throw.
                */
            readDirSync(p: string): string[];
            /**
                * Returns undefined if file is not found. Does not throw.
                */
            readFile(p: string): Promise<string>;
            readFile(p: string, encoding: 'utf8'): Promise<string>;
            readFile(p: string, encoding: 'binary'): Promise<any>;
            /**
                * SYNC! Returns undefined if file is not found. Does not throw.
                */
            readFileSync(p: string, encoding?: string): string;
            /**
                * Does not throw.
                */
            realpath(p: string): Promise<CompilerSystemRealpathResults>;
            /**
                * SYNC! Does not throw.
                */
            realpathSync(p: string): CompilerSystemRealpathResults;
            /**
                * Remove a callback which will be ran when destroy() is called.
                */
            removeDestory(cb: () => void): void;
            /**
                * Rename old path to new path. Does not throw.
                */
            rename(oldPath: string, newPath: string): Promise<CompilerSystemRenameResults>;
            resolveModuleId?(opts: ResolveModuleIdOptions): Promise<ResolveModuleIdResults>;
            resolvePath(p: string): string;
            /**
                * Does not throw.
                */
            removeDir(p: string, opts?: CompilerSystemRemoveDirectoryOptions): Promise<CompilerSystemRemoveDirectoryResults>;
            /**
                * SYNC! Does not throw.
                */
            removeDirSync(p: string, opts?: CompilerSystemRemoveDirectoryOptions): CompilerSystemRemoveDirectoryResults;
            /**
                * Does not throw.
                */
            removeFile(p: string): Promise<CompilerSystemRemoveFileResults>;
            /**
                * SYNC! Does not throw.
                */
            removeFileSync(p: string): CompilerSystemRemoveFileResults;
            setupCompiler?: (c: {
                    ts: any;
            }) => void;
            /**
                * Always returns an object. Does not throw. Check for "error" property if there's an error.
                */
            stat(p: string): Promise<CompilerFsStats>;
            /**
                * SYNC! Always returns an object. Does not throw. Check for "error" property if there's an error.
                */
            statSync(p: string): CompilerFsStats;
            tmpDirSync(): string;
            watchDirectory?(p: string, callback: CompilerFileWatcherCallback, recursive?: boolean): CompilerFileWatcher;
            watchFile?(p: string, callback: CompilerFileWatcherCallback): CompilerFileWatcher;
            /**
                * How many milliseconds to wait after a change before calling watch callbacks.
                */
            watchTimeout?: number;
            /**
                * Does not throw.
                */
            writeFile(p: string, content: string): Promise<CompilerSystemWriteFileResults>;
            /**
                * SYNC! Does not throw.
                */
            writeFileSync(p: string, content: string): CompilerSystemWriteFileResults;
    }
    export interface TranspileOnlyResults {
            diagnostics: Diagnostic[];
            output: string;
            sourceMap: any;
    }
    export interface ParsedPath {
            root: string;
            dir: string;
            base: string;
            ext: string;
            name: string;
    }
    export interface PlatformPath {
            normalize(p: string): string;
            join(...paths: string[]): string;
            resolve(...pathSegments: string[]): string;
            isAbsolute(p: string): boolean;
            relative(from: string, to: string): string;
            dirname(p: string): string;
            basename(p: string, ext?: string): string;
            extname(p: string): string;
            parse(p: string): ParsedPath;
            sep: string;
            delimiter: string;
            posix: any;
            win32: any;
    }
    export interface CompilerDependency {
            name: string;
            version: string;
            main: string;
            resources?: string[];
    }
    export interface ResolveModuleIdOptions {
            moduleId: string;
            containingFile?: string;
            exts?: string[];
            packageFilter?: (pkg: any) => void;
    }
    export interface ResolveModuleIdResults {
            moduleId: string;
            resolveId: string;
            pkgData: {
                    name: string;
                    version: string;
                    [key: string]: any;
            };
            pkgDirPath: string;
    }
    export interface WorkerMainController {
            send(...args: any[]): Promise<any>;
            handler(name: string): (...args: any[]) => Promise<any>;
            destroy(): void;
            maxWorkers: number;
    }
    export interface CopyResults {
            diagnostics: Diagnostic[];
            filePaths: string[];
            dirPaths: string[];
    }
    export interface SystemDetails {
            cpuModel: string;
            freemem(): number;
            platform: 'darwin' | 'windows' | 'linux' | '';
            release: string;
            totalmem: number;
    }
    export interface BuildOnEvents {
            on(cb: (eventName: CompilerEventName, data: any) => void): BuildOnEventRemove;
            on(eventName: CompilerEventFileAdd, cb: (path: string) => void): BuildOnEventRemove;
            on(eventName: CompilerEventFileDelete, cb: (path: string) => void): BuildOnEventRemove;
            on(eventName: CompilerEventFileUpdate, cb: (path: string) => void): BuildOnEventRemove;
            on(eventName: CompilerEventDirAdd, cb: (path: string) => void): BuildOnEventRemove;
            on(eventName: CompilerEventDirDelete, cb: (path: string) => void): BuildOnEventRemove;
            on(eventName: CompilerEventBuildStart, cb: (buildStart: CompilerBuildStart) => void): BuildOnEventRemove;
            on(eventName: CompilerEventBuildFinish, cb: (buildResults: CompilerBuildResults) => void): BuildOnEventRemove;
            on(eventName: CompilerEventBuildLog, cb: (buildLog: BuildLog) => void): BuildOnEventRemove;
            on(eventName: CompilerEventBuildNoChange, cb: () => void): BuildOnEventRemove;
    }
    export interface BuildEmitEvents {
            emit(eventName: CompilerEventFileAdd, path: string): void;
            emit(eventName: CompilerEventFileDelete, path: string): void;
            emit(eventName: CompilerEventFileUpdate, path: string): void;
            emit(eventName: CompilerEventDirAdd, path: string): void;
            emit(eventName: CompilerEventDirDelete, path: string): void;
            emit(eventName: CompilerEventBuildStart, buildStart: CompilerBuildStart): void;
            emit(eventName: CompilerEventBuildFinish, buildResults: CompilerBuildResults): void;
            emit(eventName: CompilerEventBuildNoChange, buildNoChange: BuildNoChangeResults): void;
            emit(eventName: CompilerEventBuildLog, buildLog: BuildLog): void;
            emit(eventName: CompilerEventFsChange, fsWatchResults: FsWatchResults): void;
    }
    export interface FsWatchResults {
            dirsAdded: string[];
            dirsDeleted: string[];
            filesUpdated: string[];
            filesAdded: string[];
            filesDeleted: string[];
    }
    export interface BuildLog {
            buildId: number;
            messages: string[];
            progress: number;
    }
    export interface BuildNoChangeResults {
            buildId: number;
            noChange: boolean;
    }
    export interface CompilerBuildResults {
            buildId: number;
            componentGraph?: BuildResultsComponentGraph;
            diagnostics: Diagnostic[];
            dirsAdded: string[];
            dirsDeleted: string[];
            duration: number;
            filesAdded: string[];
            filesChanged: string[];
            filesDeleted: string[];
            filesUpdated: string[];
            hasError: boolean;
            hasSuccessfulBuild: boolean;
            hmr?: HotModuleReplacement;
            hydrateAppFilePath?: string;
            isRebuild: boolean;
            namespace: string;
            outputs: BuildOutput[];
            rootDir: string;
            srcDir: string;
            timestamp: string;
    }
    export interface BuildResultsComponentGraph {
            [scopeId: string]: string[];
    }
    export interface BuildOutput {
            type: string;
            files: string[];
    }
    export interface HotModuleReplacement {
            componentsUpdated?: string[];
            excludeHmr?: string[];
            externalStylesUpdated?: string[];
            imagesUpdated?: string[];
            indexHtmlUpdated?: boolean;
            inlineStylesUpdated?: HmrStyleUpdate[];
            reloadStrategy: PageReloadStrategy;
            scriptsAdded?: string[];
            scriptsDeleted?: string[];
            serviceWorkerUpdated?: boolean;
            versionId?: string;
    }
    export interface HmrStyleUpdate {
            styleId: string;
            styleTag: string;
            styleText: string;
    }
    export type BuildOnEventRemove = () => boolean;
    export interface BuildEvents extends BuildOnEvents, BuildEmitEvents {
            unsubscribeAll(): void;
    }
    export interface CompilerBuildStart {
            buildId: number;
            timestamp: string;
    }
    export type CompilerFileWatcherCallback = (fileName: string, eventKind: CompilerFileWatcherEvent) => void;
    export type CompilerFileWatcherEvent = CompilerEventFileAdd | CompilerEventFileDelete | CompilerEventFileUpdate | CompilerEventDirAdd | CompilerEventDirDelete;
    export type CompilerEventName = CompilerEventFsChange | CompilerEventFileUpdate | CompilerEventFileAdd | CompilerEventFileDelete | CompilerEventDirAdd | CompilerEventDirDelete | CompilerEventBuildStart | CompilerEventBuildFinish | CompilerEventBuildNoChange | CompilerEventBuildLog;
    export type CompilerEventFsChange = 'fsChange';
    export type CompilerEventFileUpdate = 'fileUpdate';
    export type CompilerEventFileAdd = 'fileAdd';
    export type CompilerEventFileDelete = 'fileDelete';
    export type CompilerEventDirAdd = 'dirAdd';
    export type CompilerEventDirDelete = 'dirDelete';
    export type CompilerEventBuildStart = 'buildStart';
    export type CompilerEventBuildFinish = 'buildFinish';
    export type CompilerEventBuildLog = 'buildLog';
    export type CompilerEventBuildNoChange = 'buildNoChange';
    export interface CompilerFileWatcher {
            close(): void | Promise<void>;
    }
    export interface CompilerFsStats {
            /**
                * If it's a directory. `false` if there was an error.
                */
            isDirectory: boolean;
            /**
                * If it's a file. `false` if there was an error.
                */
            isFile: boolean;
            /**
                * If it's a symlink. `false` if there was an error.
                */
            isSymbolicLink: boolean;
            /**
                * The size of the file in bytes. `0` for directories or if there was an error.
                */
            size: number;
            /**
                * The timestamp indicating the last time this file was modified expressed in milliseconds since the POSIX Epoch.
                */
            mtimeMs?: number;
            /**
                * Error if there was one, otherwise `null`. `stat` and `statSync` do not throw errors but always returns this interface.
                */
            error: any;
    }
    export interface CompilerSystemCreateDirectoryOptions {
            /**
                * Indicates whether parent directories should be created.
                * @default false
                */
            recursive?: boolean;
            /**
                * A file mode. If a string is passed, it is parsed as an octal integer. If not specified
                * @default 0o777.
                */
            mode?: number;
    }
    export interface CompilerSystemCreateDirectoryResults {
            basename: string;
            dirname: string;
            path: string;
            newDirs: string[];
            error: any;
    }
    export interface CompilerSystemRemoveDirectoryOptions {
            /**
                * Indicates whether child files and subdirectories should be removed.
                * @default false
                */
            recursive?: boolean;
    }
    export interface CompilerSystemRemoveDirectoryResults {
            basename: string;
            dirname: string;
            path: string;
            removedDirs: string[];
            removedFiles: string[];
            error: any;
    }
    export interface CompilerSystemRenameResults extends CompilerSystemRenamedPath {
            renamed: CompilerSystemRenamedPath[];
            oldDirs: string[];
            oldFiles: string[];
            newDirs: string[];
            newFiles: string[];
            error: any;
    }
    export interface CompilerSystemRenamedPath {
            oldPath: string;
            newPath: string;
            isFile: boolean;
            isDirectory: boolean;
    }
    export interface CompilerSystemRealpathResults {
            path: string;
            error: any;
    }
    export interface CompilerSystemRemoveFileResults {
            basename: string;
            dirname: string;
            path: string;
            error: any;
    }
    export interface CompilerSystemWriteFileResults {
            path: string;
            error: any;
    }
    export interface Credentials {
            key: string;
            cert: string;
    }
    export interface ConfigBundle {
            components: string[];
    }
    export interface CopyTask {
            src: string;
            dest?: string;
            warn?: boolean;
            keepDirStructure?: boolean;
    }
    export interface BundlingConfig {
            namedExports?: {
                    [key: string]: string[];
            };
    }
    export interface NodeResolveConfig {
            module?: boolean;
            jsnext?: boolean;
            main?: boolean;
            browser?: boolean;
            extensions?: string[];
            preferBuiltins?: boolean;
            jail?: string;
            only?: Array<string | RegExp>;
            modulesOnly?: boolean;
            /**
                * @see https://github.com/browserify/resolve#resolveid-opts-cb
                */
            customResolveOptions?: {
                    basedir?: string;
                    package?: string;
                    extensions?: string[];
                    readFile?: Function;
                    isFile?: Function;
                    isDirectory?: Function;
                    packageFilter?: Function;
                    pathFilter?: Function;
                    paths?: Function | string[];
                    moduleDirectory?: string | string[];
                    preserveSymlinks?: boolean;
            };
    }
    export interface RollupConfig {
            inputOptions?: RollupInputOptions;
            outputOptions?: RollupOutputOptions;
    }
    export interface RollupInputOptions {
            context?: string;
            moduleContext?: ((id: string) => string) | {
                    [id: string]: string;
            };
            treeshake?: boolean;
    }
    export interface RollupOutputOptions {
            globals?: {
                    [name: string]: string;
            } | ((name: string) => string);
    }
    export interface Testing {
            run(opts: TestingRunOptions): Promise<boolean>;
            destroy(): Promise<void>;
    }
    export interface TestingRunOptions {
            e2e?: boolean;
            screenshot?: boolean;
            spec?: boolean;
            updateScreenshot?: boolean;
    }
    export interface JestConfig {
            /**
                * This option tells Jest that all imported modules in your tests should be mocked automatically.
                * All modules used in your tests will have a replacement implementation, keeping the API surface. Default: false
                */
            automock?: boolean;
            /**
                * By default, Jest runs all tests and produces all errors into the console upon completion.
                * The bail config option can be used here to have Jest stop running tests after the first failure. Default: false
                */
            bail?: boolean;
            /**
                * The directory where Jest should store its cached dependency information. Jest attempts to scan your dependency tree once (up-front)
                * and cache it in order to ease some of the filesystem raking that needs to happen while running tests. This config option lets you
                * customize where Jest stores that cache data on disk. Default: "/tmp/<path>"
                */
            cacheDirectory?: string;
            /**
                * Automatically clear mock calls and instances between every test. Equivalent to calling jest.clearAllMocks()
                * between each test. This does not remove any mock implementation that may have been provided. Default: false
                */
            clearMocks?: boolean;
            /**
                * Indicates whether the coverage information should be collected while executing the test. Because this retrofits all
                * executed files with coverage collection statements, it may significantly slow down your tests. Default: false
                */
            collectCoverage?: boolean;
            /**
                * An array of glob patterns indicating a set of files for which coverage information should be collected.
                * If a file matches the specified glob pattern, coverage information will be collected for it even if no tests exist
                * for this file and it's never required in the test suite. Default: undefined
                */
            collectCoverageFrom?: any[];
            /**
                * The directory where Jest should output its coverage files. Default: undefined
                */
            coverageDirectory?: string;
            /**
                * An array of regexp pattern strings that are matched against all file paths before executing the test. If the file path matches
                * any of the patterns, coverage information will be skipped. These pattern strings match against the full path.
                * Use the <rootDir> string token to include the path to your project's root directory to prevent it from accidentally
                * ignoring all of your files in different environments that may have different root directories.
                * Example: ["<rootDir>/build/", "<rootDir>/node_modules/"]. Default: ["/node_modules/"]
                */
            coveragePathIgnorePatterns?: any[];
            /**
                * A list of reporter names that Jest uses when writing coverage reports. Any istanbul reporter can be used.
                * Default: ["json", "lcov", "text"]
                */
            coverageReporters?: any[];
            /**
                * This will be used to configure minimum threshold enforcement for coverage results. Thresholds can be specified as global,
                * as a glob, and as a directory or file path. If thresholds aren't met, jest will fail. Thresholds specified as a positive
                * number are taken to be the minimum percentage required. Thresholds specified as a negative number represent the maximum
                * number of uncovered entities allowed. Default: undefined
                */
            coverageThreshold?: any;
            errorOnDeprecated?: boolean;
            forceCoverageMatch?: any[];
            globals?: any;
            globalSetup?: string;
            globalTeardown?: string;
            /**
                * An array of directory names to be searched recursively up from the requiring module's location. Setting this option will
                * override the default, if you wish to still search node_modules for packages include it along with any other
                * options: ["node_modules", "bower_components"]. Default: ["node_modules"]
                */
            moduleDirectories?: string[];
            /**
                * An array of file extensions your modules use. If you require modules without specifying a file extension,
                * these are the extensions Jest will look for. Default: ['ts', 'tsx', 'js', 'json']
                */
            moduleFileExtensions?: string[];
            moduleNameMapper?: any;
            modulePaths?: any[];
            modulePathIgnorePatterns?: any[];
            notify?: boolean;
            notifyMode?: string;
            preset?: string;
            prettierPath?: string;
            projects?: any;
            reporters?: any;
            resetMocks?: boolean;
            resetModules?: boolean;
            resolver?: string;
            restoreMocks?: string;
            rootDir?: string;
            roots?: any[];
            runner?: string;
            /**
                * The paths to modules that run some code to configure or set up the testing environment before each test.
                * Since every test runs in its own environment, these scripts will be executed in the testing environment
                * immediately before executing the test code itself. Default: []
                */
            setupFiles?: string[];
            setupFilesAfterEnv?: string[];
            snapshotSerializers?: any[];
            testEnvironment?: string;
            testEnvironmentOptions?: any;
            testMatch?: string[];
            testPathIgnorePatterns?: string[];
            testPreset?: string;
            testRegex?: string;
            testResultsProcessor?: string;
            testRunner?: string;
            testURL?: string;
            timers?: string;
            transform?: {
                    [key: string]: string;
            };
            transformIgnorePatterns?: any[];
            unmockedModulePathPatterns?: any[];
            verbose?: boolean;
            watchPathIgnorePatterns?: any[];
    }
    export interface TestingConfig extends JestConfig {
            /**
                * The `allowableMismatchedPixels` value is used to determine an acceptable
                * number of pixels that can be mismatched before the image is considered
                * to have changes. Realistically, two screenshots representing the same
                * content may have a small number of pixels that are not identical due to
                * anti-aliasing, which is perfectly normal. If the `allowableMismatchedRatio`
                * is provided it will take precedence, otherwise `allowableMismatchedPixels`
                * will be used.
                */
            allowableMismatchedPixels?: number;
            /**
                * The `allowableMismatchedRatio` ranges from `0` to `1` and is used to
                * determine an acceptable ratio of pixels that can be mismatched before
                * the image is considered to have changes. Realistically, two screenshots
                * representing the same content may have a small number of pixels that
                * are not identical due to anti-aliasing, which is perfectly normal. The
                * `allowableMismatchedRatio` is the number of pixels that were mismatched,
                * divided by the total number of pixels in the screenshot. For example,
                * a ratio value of `0.06` means 6% of the pixels can be mismatched before
                * the image is considered to have changes. If the `allowableMismatchedRatio`
                * is provided it will take precedence, otherwise `allowableMismatchedPixels`
                * will be used.
                */
            allowableMismatchedRatio?: number;
            /**
                * Matching threshold while comparing two screenshots. Value ranges from `0` to `1`.
                * Smaller values make the comparison more sensitive. The `pixelmatchThreshold`
                * value helps to ignore anti-aliasing. Default: `0.1`
                */
            pixelmatchThreshold?: number;
            /**
                * Additional arguments to pass to the browser instance.
                */
            browserArgs?: string[];
            /**
                * Path to a Chromium or Chrome executable to run instead of the bundled Chromium.
                */
            browserExecutablePath?: string;
            /**
                * Url of remote Chrome instance to use instead of local Chrome.
                */
            browserWSEndpoint?: string;
            /**
                * Whether to run browser e2e tests in headless mode. Defaults to true.
                */
            browserHeadless?: boolean;
            /**
                * Slows down e2e browser operations by the specified amount of milliseconds.
                * Useful so that you can see what is going on.
                */
            browserSlowMo?: number;
            /**
                * By default, all E2E pages wait until the "load" event, this global setting can be used
                * to change the default `waitUntil` behaviour.
                */
            browserWaitUntil?: 'load' | 'domcontentloaded' | 'networkidle0' | 'networkidle2';
            /**
                * Whether to auto-open a DevTools panel for each tab.
                * If this option is true, the headless option will be set false
                */
            browserDevtools?: boolean;
            /**
                * Array of browser emulations to be using during e2e tests. A full e2e
                * test is ran for each emulation.
                */
            emulate?: EmulateConfig[];
            /**
                * Path to the Screenshot Connector module.
                */
            screenshotConnector?: string;
            /**
                * Amount of time in milliseconds to wait before a screenshot is taken.
                */
            waitBeforeScreenshot?: number;
    }
    export interface EmulateConfig {
            /**
                * Predefined device descriptor name, such as "iPhone X" or "Nexus 10".
                * For a complete list please see: https://github.com/GoogleChrome/puppeteer/blob/master/DeviceDescriptors.js
                */
            device?: string;
            /**
                * User-Agent to be used. Defaults to the user-agent of the installed Puppeteer version.
                */
            userAgent?: string;
            viewport?: EmulateViewport;
    }
    export interface EmulateViewport {
            /**
                * Page width in pixels.
                */
            width: number;
            /**
                * page height in pixels.
                */
            height: number;
            /**
                * Specify device scale factor (can be thought of as dpr). Defaults to 1.
                */
            deviceScaleFactor?: number;
            /**
                * Whether the meta viewport tag is taken into account. Defaults to false.
                */
            isMobile?: boolean;
            /**
                * Specifies if viewport supports touch events. Defaults to false
                */
            hasTouch?: boolean;
            /**
                * Specifies if viewport is in landscape mode. Defaults to false.
                */
            isLandscape?: boolean;
    }
    export type LogLevel = 'debug' | 'info' | 'warn' | 'error' | string;
    /**
        * Common logger to be used by the compiler, dev-server and CLI. The CLI will use a
        * NodeJS based console logging and colors, and the web will use browser based
        * logs and colors.
        */
    export interface Logger {
            enableColors: (useColors: boolean) => void;
            setLevel: (level: LogLevel) => void;
            getLevel: () => LogLevel;
            debug: (...msg: any[]) => void;
            info: (...msg: any[]) => void;
            warn: (...msg: any[]) => void;
            error: (...msg: any[]) => void;
            createTimeSpan: (startMsg: string, debug?: boolean, appendTo?: string[]) => LoggerTimeSpan;
            printDiagnostics: (diagnostics: Diagnostic[], cwd?: string) => void;
            red: (msg: string) => string;
            green: (msg: string) => string;
            yellow: (msg: string) => string;
            blue: (msg: string) => string;
            magenta: (msg: string) => string;
            cyan: (msg: string) => string;
            gray: (msg: string) => string;
            bold: (msg: string) => string;
            dim: (msg: string) => string;
            bgRed: (msg: string) => string;
            emoji: (e: string) => string;
            setLogFilePath?: (p: string) => void;
            writeLogs?: (append: boolean) => void;
            createLineUpdater?: () => Promise<LoggerLineUpdater>;
    }
    export interface LoggerLineUpdater {
            update(text: string): Promise<void>;
            stop(): Promise<void>;
    }
    export interface LoggerTimeSpan {
            duration(): number;
            finish(finishedMsg: string, color?: string, bold?: boolean, newLineSuffix?: boolean): number;
    }
    export interface OutputTargetDist extends OutputTargetBase {
            type: 'dist';
            buildDir?: string;
            dir?: string;
            collectionDir?: string | null;
            typesDir?: string;
            esmLoaderPath?: string;
            copy?: CopyTask[];
            polyfills?: boolean;
            empty?: boolean;
    }
    export interface OutputTargetDistCollection extends OutputTargetBase {
            type: 'dist-collection';
            dir: string;
            collectionDir: string;
    }
    export interface OutputTargetDistTypes extends OutputTargetBase {
            type: 'dist-types';
            dir: string;
            typesDir: string;
    }
    export interface OutputTargetDistLazy extends OutputTargetBase {
            type: 'dist-lazy';
            dir?: string;
            esmDir?: string;
            esmEs5Dir?: string;
            systemDir?: string;
            cjsDir?: string;
            polyfills?: boolean;
            isBrowserBuild?: boolean;
            esmIndexFile?: string;
            cjsIndexFile?: string;
            systemLoaderFile?: string;
            empty?: boolean;
    }
    export interface OutputTargetDistGlobalStyles extends OutputTargetBase {
            type: 'dist-global-styles';
            file: string;
    }
    export interface OutputTargetDistLazyLoader extends OutputTargetBase {
            type: 'dist-lazy-loader';
            dir: string;
            esmDir: string;
            esmEs5Dir: string;
            cjsDir: string;
            componentDts: string;
            empty: boolean;
    }
    export interface OutputTargetHydrate extends OutputTargetBase {
            type: 'dist-hydrate-script';
            dir?: string;
            /**
                * Module IDs that should not be bundled into the script.
                * By default, all node builtin's, such as `fs` or `path`
                * will be considered "external" and not bundled.
                */
            external?: string[];
            empty?: boolean;
    }
    export interface OutputTargetCustom extends OutputTargetBase {
            type: 'custom';
            name: string;
            validate?: (config: Config, diagnostics: Diagnostic[]) => void;
            generator: (config: Config, compilerCtx: any, buildCtx: any, docs: any) => Promise<void>;
            copy?: CopyTask[];
    }
    export interface OutputTargetDocsVscode extends OutputTargetBase {
            type: 'docs-vscode';
            file: string;
            sourceCodeBaseUrl?: string;
    }
    export interface OutputTargetDocsReadme extends OutputTargetBase {
            type: 'docs-readme';
            dir?: string;
            dependencies?: boolean;
            footer?: string;
            strict?: boolean;
    }
    export interface OutputTargetDocsJson extends OutputTargetBase {
            type: 'docs-json';
            file: string;
            typesFile?: string | null;
            strict?: boolean;
    }
    export interface OutputTargetDocsCustom extends OutputTargetBase {
            type: 'docs-custom';
            generator: (docs: JsonDocs, config: Config) => void | Promise<void>;
            strict?: boolean;
    }
    export interface OutputTargetStats extends OutputTargetBase {
            type: 'stats';
            file?: string;
    }
    export interface OutputTargetBaseNext {
            type: string;
            dir?: string;
    }
    export interface OutputTargetDistCustomElements extends OutputTargetBaseNext {
            type: 'dist-custom-elements';
            empty?: boolean;
            externalRuntime?: boolean;
            copy?: CopyTask[];
            inlineDynamicImports?: boolean;
            includeGlobalScripts?: boolean;
            minify?: boolean;
    }
    export interface OutputTargetDistCustomElementsBundle extends OutputTargetBaseNext {
            type: 'dist-custom-elements-bundle';
            empty?: boolean;
            externalRuntime?: boolean;
            copy?: CopyTask[];
            inlineDynamicImports?: boolean;
            includeGlobalScripts?: boolean;
            minify?: boolean;
    }
    export interface OutputTargetBase {
            type: string;
    }
    export type OutputTargetBuild = OutputTargetDistCollection | OutputTargetDistLazy;
    export interface OutputTargetAngular extends OutputTargetBase {
            type: 'angular';
            componentCorePackage: string;
            directivesProxyFile?: string;
            directivesArrayFile?: string;
            directivesUtilsFile?: string;
            excludeComponents?: string[];
    }
    export interface OutputTargetCopy extends OutputTargetBase {
            type: 'copy';
            dir: string;
            copy?: CopyTask[];
            copyAssets?: 'collection' | 'dist';
    }
    export interface OutputTargetWww extends OutputTargetBase {
            /**
                * Webapp output target.
                */
            type: 'www';
            /**
                * The directory to write the app's JavaScript and CSS build
                * files to. The default is to place this directory as a child
                * to the `dir` config. Default: `build`
                */
            buildDir?: string;
            /**
                * The directory to write the entire application to.
                * Note, the `buildDir` is where the app's JavaScript and CSS build
                * files are written. Default: `www`
                */
            dir?: string;
            /**
                * Empty the build directory of all files and directories on first build.
                * Default: `true`
                */
            empty?: boolean;
            /**
                * The default index html file of the app, commonly found at the
                * root of the `src` directory.
                * Default: `index.html`
                */
            indexHtml?: string;
            /**
                * The copy config is an array of objects that defines any files or folders that should
                * be copied over to the build directory.
                *
                * Each object in the array must include a src property which can be either an absolute path,
                * a relative path or a glob pattern. The config can also provide an optional dest property
                * which can be either an absolute path or a path relative to the build directory.
                * Also note that any files within src/assets are automatically copied to www/assets for convenience.
                *
                * In the copy config below, it will copy the entire directory from src/docs-content over to www/docs-content.
                */
            copy?: CopyTask[];
            /**
                * The base url of the app, it's required during prerendering to be the absolute path
                * of your app, such as: `https://my.app.com/app`.
                *
                * Default: `/`
                */
            baseUrl?: string;
            /**
                * By default, stencil will include all the polyfills required by legacy browsers in the ES5 build.
                * If it's `false`, stencil will not emit this polyfills anymore and it's your responsability to provide them before
                * stencil initializes.
                */
            polyfills?: boolean;
            /**
                * Path to an external node module which has exports of the prerender config object.
                * ```
                * module.exports = {
                *   afterHydrate(document, url) {
                *     document.title = `URL: ${url.href}`;
                *   }
                * }
                * ```
                */
            prerenderConfig?: string;
            /**
                * Service worker config for production builds. During development builds
                * service worker script will be injected to automatically unregister existing
                * service workers. When set to `false` neither a service worker registration
                * or unregistration will be added to the index.html.
                */
            serviceWorker?: ServiceWorkerConfig | null | false;
            appDir?: string;
    }
    export type OutputTarget = OutputTargetAngular | OutputTargetCopy | OutputTargetCustom | OutputTargetDist | OutputTargetDistCollection | OutputTargetDistCustomElements | OutputTargetDistCustomElementsBundle | OutputTargetDistLazy | OutputTargetDistGlobalStyles | OutputTargetDistLazyLoader | OutputTargetDocsJson | OutputTargetDocsCustom | OutputTargetDocsReadme | OutputTargetDocsVscode | OutputTargetWww | OutputTargetHydrate | OutputTargetStats | OutputTargetDistTypes;
    export interface ServiceWorkerConfig {
            unregister?: boolean;
            swDest?: string;
            swSrc?: string;
            globPatterns?: string[];
            globDirectory?: string | string[];
            globIgnores?: string | string[];
            templatedUrls?: any;
            maximumFileSizeToCacheInBytes?: number;
            manifestTransforms?: any;
            modifyUrlPrefix?: any;
            dontCacheBustURLsMatching?: RegExp;
            navigateFallback?: string;
            navigateFallbackWhitelist?: RegExp[];
            navigateFallbackBlacklist?: RegExp[];
            cacheId?: string;
            skipWaiting?: boolean;
            clientsClaim?: boolean;
            directoryIndex?: string;
            runtimeCaching?: any[];
            ignoreUrlParametersMatching?: any[];
            handleFetch?: boolean;
    }
    export interface LoadConfigInit {
            /**
                * User config object to merge into default config and
                * config loaded from a file path.
                */
            config?: Config;
            /**
                * Absolute path to a Stencil config file. This path cannot be
                * relative and it does not resolve config files within a directory.
                */
            configPath?: string;
            logger?: Logger;
            sys?: CompilerSystem;
            /**
                * When set to true, if the "tsconfig.json" file is not found
                * it'll automatically generate and save a default tsconfig
                * within the root directory.
                */
            initTsConfig?: boolean;
    }
    export interface LoadConfigResults {
            config: Config;
            diagnostics: Diagnostic[];
            tsconfig: {
                    path: string;
                    compilerOptions: any;
                    files: string[];
                    include: string[];
                    exclude: string[];
                    extends: string;
            };
    }
    export interface Diagnostic {
            level: 'error' | 'warn' | 'info' | 'log' | 'debug';
            type: string;
            header?: string;
            language?: string;
            messageText: string;
            debugText?: string;
            code?: string;
            absFilePath?: string;
            relFilePath?: string;
            lineNumber?: number;
            columnNumber?: number;
            lines?: {
                    lineIndex: number;
                    lineNumber: number;
                    text?: string;
                    errorCharStart: number;
                    errorLength?: number;
            }[];
    }
    export interface CacheStorage {
            get(key: string): Promise<any>;
            set(key: string, value: any): Promise<void>;
    }
    export interface WorkerOptions {
            maxConcurrentWorkers?: number;
            maxConcurrentTasksPerWorker?: number;
            logger?: Logger;
    }
    export interface RollupInterface {
            rollup: {
                    (config: any): Promise<any>;
            };
            plugins: {
                    nodeResolve(opts: any): any;
                    replace(opts: any): any;
                    commonjs(opts: any): any;
                    json(): any;
            };
    }
    export interface ResolveModuleOptions {
            manuallyResolve?: boolean;
            packageJson?: boolean;
    }
    export interface PrerenderStartOptions {
            buildId?: string;
            hydrateAppFilePath: string;
            componentGraph: BuildResultsComponentGraph;
            srcIndexHtmlPath: string;
    }
    export interface PrerenderResults {
            buildId: string;
            diagnostics: Diagnostic[];
            urls: number;
            duration: number;
            average: number;
    }
    export interface OptimizeCssInput {
            input: string;
            filePath?: string;
            autoprefixer?: any;
            minify?: boolean;
            sourceMap?: boolean;
            resolveUrl?: (url: string) => Promise<string> | string;
    }
    export interface OptimizeCssOutput {
            output: string;
            diagnostics: Diagnostic[];
    }
    export interface OptimizeJsInput {
            input: string;
            filePath?: string;
            target?: 'es5' | 'latest';
            pretty?: boolean;
            sourceMap?: boolean;
    }
    export interface OptimizeJsOutput {
            output: string;
            sourceMap: any;
            diagnostics: Diagnostic[];
    }
    export interface LazyRequire {
            ensure(fromDir: string, moduleIds: string[]): Promise<Diagnostic[]>;
            require(fromDir: string, moduleId: string): any;
            getModulePath(fromDir: string, moduleId: string): string;
    }
    export interface FsWatcherItem {
            close(): void;
    }
    export interface MakeDirectoryOptions {
            /**
                * Indicates whether parent folders should be created.
                * @default false
                */
            recursive?: boolean;
            /**
                * A file mode. If a string is passed, it is parsed as an octal integer. If not specified
                * @default 0o777.
                */
            mode?: number;
    }
    export interface FsStats {
            isFile(): boolean;
            isDirectory(): boolean;
            isBlockDevice(): boolean;
            isCharacterDevice(): boolean;
            isSymbolicLink(): boolean;
            isFIFO(): boolean;
            isSocket(): boolean;
            dev: number;
            ino: number;
            mode: number;
            nlink: number;
            uid: number;
            gid: number;
            rdev: number;
            size: number;
            blksize: number;
            blocks: number;
            atime: Date;
            mtime: Date;
            ctime: Date;
            birthtime: Date;
    }
    export interface FsWriteOptions {
            inMemoryOnly?: boolean;
            clearFileCache?: boolean;
            immediateWrite?: boolean;
            useCache?: boolean;
            outputTargetType?: string;
    }
    export interface Compiler {
            build(): Promise<CompilerBuildResults>;
            createWatcher(): Promise<CompilerWatcher>;
            destroy(): Promise<void>;
            sys: CompilerSystem;
    }
    export interface CompilerWatcher extends BuildOnEvents {
            start: () => Promise<WatcherCloseResults>;
            close: () => Promise<WatcherCloseResults>;
            request: (data: CompilerRequest) => Promise<CompilerRequestResponse>;
    }
    export interface CompilerRequest {
            path?: string;
    }
    export interface WatcherCloseResults {
            exitCode: number;
    }
    export interface CompilerRequestResponse {
            path: string;
            nodeModuleId: string;
            nodeModuleVersion: string;
            nodeResolvedPath: string;
            cachePath: string;
            cacheHit: boolean;
            content: string;
            status: number;
    }
    export interface TranspileOptions {
            /**
                * A component can be defined as a custom element by using `customelement`, or the
                * component class can be exported by using `module`. Default is `customelement`.
                */
            componentExport?: 'customelement' | 'module' | string | undefined;
            /**
                * Sets how and if component metadata should be assigned on the compiled
                * component output. The `compilerstatic` value will set the metadata to
                * a static `COMPILER_META` getter on the component class. This option
                * is useful for unit testing preprocessors. Default is `null`.
                */
            componentMetadata?: 'runtimestatic' | 'compilerstatic' | string | undefined;
            /**
                * The actual internal import path for any `@stencil/core` imports.
                * Default is `@stencil/core/internal/client`.
                */
            coreImportPath?: string;
            /**
                * The current working directory. Default is `/`.
                */
            currentDirectory?: string;
            /**
                * The filename of the code being compiled. Default is `module.tsx`.
                */
            file?: string;
            /**
                * Module format to use for the compiled code output, which can be either `esm` or `cjs`.
                * Default is `esm`.
                */
            module?: 'cjs' | 'esm' | string;
            /**
                * Sets how and if any properties, methods and events are proxied on the
                * component class. The `defineproperty` value sets the getters and setters
                * using Object.defineProperty. Default is `defineproperty`.
                */
            proxy?: 'defineproperty' | string | undefined;
            /**
                * How component styles should be associated to the component. The `static`
                * setting will assign the styles as a static getter on the component class.
                */
            style?: 'static' | string | undefined;
            /**
                * How style data should be added for imports. For example, the `queryparams` value
                * adds the component's tagname and encapsulation info as querystring parameter
                * to the style's import, such as `style.css?tag=my-tag&encapsulation=shadow`. This
                * style data can be used by bundlers to further optimize each component's css.
                * Set to `null` to not include the querystring parameters. Default is `queryparams`.
                */
            styleImportData?: 'queryparams' | string | undefined;
            /**
                * The JavaScript source target TypeScript should to transpile to. Values can be
                * `latest`, `esnext`, `es2017`, `es2015`, or `es5`. Defaults to `latest`.
                */
            target?: CompileTarget;
            /**
                * Create a source map. Using `inline` will inline the source map into the
                * code, otherwise the source map will be in the returned `map` property.
                * Default is `true`.
                */
            sourceMap?: boolean | 'inline';
            /**
                * Base directory to resolve non-relative module names. Same as the `baseUrl`
                * TypeScript compiler option: https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping
                */
            baseUrl?: string;
            /**
                * List of path mapping entries for module names to locations relative to the `baseUrl`.
                * Same as the `paths` TypeScript compiler option:
                * https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping
                */
            paths?: {
                    [key: string]: string[];
            };
            /**
                * Passed in Stencil Compiler System, otherwise falls back to the internal in-memory only system.
                */
            sys?: CompilerSystem;
    }
    export type CompileTarget = 'latest' | 'esnext' | 'es2020' | 'es2019' | 'es2018' | 'es2017' | 'es2015' | 'es5' | string | undefined;
    export interface TranspileResults {
            code: string;
            data?: any[];
            diagnostics: Diagnostic[];
            imports?: {
                    path: string;
            }[];
            inputFileExtension: string;
            inputFilePath: string;
            map: any;
            outputFilePath: string;
    }
    export interface TransformOptions {
            coreImportPath: string;
            componentExport: 'lazy' | 'module' | 'customelement' | null;
            componentMetadata: 'runtimestatic' | 'compilerstatic' | null;
            currentDirectory: string;
            file?: string;
            isolatedModules?: boolean;
            module?: 'cjs' | 'esm';
            proxy: 'defineproperty' | null;
            style: 'static' | null;
            styleImportData: 'queryparams' | null;
            target?: string;
    }
    export interface CompileScriptMinifyOptions {
            target?: CompileTarget;
            pretty?: boolean;
    }
    export interface DevServer extends BuildEmitEvents {
            address: string;
            basePath: string;
            browserUrl: string;
            protocol: string;
            port: number;
            root: string;
            close(): Promise<void>;
    }
    export interface CliInitOptions {
            args: string[];
            logger: Logger;
            sys: CompilerSystem;
    }
}

declare module '@stencil/core/stencil-public-docs' {
    export interface JsonDocs {
        components: JsonDocsComponent[];
        timestamp: string;
        compiler: {
            name: string;
            version: string;
            typescriptVersion: string;
        };
    }
    export interface JsonDocsComponent {
        dirPath?: string;
        fileName?: string;
        filePath?: string;
        readmePath?: string;
        usagesDir?: string;
        encapsulation: 'shadow' | 'scoped' | 'none';
        tag: string;
        readme: string;
        docs: string;
        docsTags: JsonDocsTag[];
        usage: JsonDocsUsage;
        props: JsonDocsProp[];
        methods: JsonDocsMethod[];
        events: JsonDocsEvent[];
        listeners: JsonDocsListener[];
        styles: JsonDocsStyle[];
        slots: JsonDocsSlot[];
        parts: JsonDocsPart[];
        dependents: string[];
        dependencies: string[];
        dependencyGraph: JsonDocsDependencyGraph;
        deprecation?: string;
    }
    export interface JsonDocsDependencyGraph {
        [tagName: string]: string[];
    }
    export interface JsonDocsTag {
        name: string;
        text?: string;
    }
    export interface JsonDocsValue {
        value?: string;
        type: string;
    }
    export interface JsonDocsUsage {
        [key: string]: string;
    }
    export interface JsonDocsProp {
        name: string;
        type: string;
        mutable: boolean;
        attr?: string;
        reflectToAttr: boolean;
        docs: string;
        docsTags: JsonDocsTag[];
        default: string;
        deprecation?: string;
        values: JsonDocsValue[];
        optional: boolean;
        required: boolean;
    }
    export interface JsonDocsMethod {
        name: string;
        docs: string;
        docsTags: JsonDocsTag[];
        deprecation?: string;
        signature: string;
        returns: JsonDocsMethodReturn;
        parameters: JsonDocMethodParameter[];
    }
    export interface JsonDocsMethodReturn {
        type: string;
        docs: string;
    }
    export interface JsonDocMethodParameter {
        name: string;
        type: string;
        docs: string;
    }
    export interface JsonDocsEvent {
        event: string;
        bubbles: boolean;
        cancelable: boolean;
        composed: boolean;
        docs: string;
        docsTags: JsonDocsTag[];
        deprecation?: string;
        detail: string;
    }
    export interface JsonDocsStyle {
        name: string;
        docs: string;
        annotation: string;
    }
    export interface JsonDocsListener {
        event: string;
        target?: string;
        capture: boolean;
        passive: boolean;
    }
    export interface JsonDocsSlot {
        name: string;
        docs: string;
    }
    export interface JsonDocsPart {
        name: string;
        docs: string;
    }
    export interface StyleDoc {
        name: string;
        docs: string;
        annotation: 'prop';
    }
}

declare module '@stencil/core/' {
    export * from '@stencil/core/stencil-private';
    export * from '@stencil/core/stencil-public-compiler';
    export * from '@stencil/core/stencil-public-runtime';
}

declare module '@stencil/core/stencil-private' {
    import type { BuildEvents, BuildLog, BuildOutput, CompilerBuildResults, CompilerBuildStart, CompilerFsStats, CompilerRequestResponse, CompilerSystem, Config, CopyResults, DevServerConfig, DevServerEditor, Diagnostic, FsWriteOptions, Logger, LoggerTimeSpan, OptimizeCssInput, OptimizeCssOutput, OutputTargetWww, PageReloadStrategy, PrerenderConfig, StyleDoc, LoggerLineUpdater } from '@stencil/core/stencil-public-compiler';
    import type { ComponentInterface, ListenOptions, ListenTargetOptions, VNode, VNodeData } from '@stencil/core/stencil-public-runtime';
    export interface PrintLine {
            lineIndex: number;
            lineNumber: number;
            text?: string;
            errorCharStart: number;
            errorLength?: number;
    }
    export interface AssetsMeta {
            absolutePath: string;
            cmpRelativePath: string;
            originalComponentPath: string;
    }
    export interface ParsedImport {
            importPath: string;
            basename: string;
            ext: string;
            data: ImportData;
    }
    export interface ImportData {
            tag?: string;
            encapsulation?: string;
            mode?: string;
    }
    export interface SerializeImportData extends ImportData {
            importeePath: string;
            importerPath?: string;
    }
    export interface BuildFeatures {
            style: boolean;
            mode: boolean;
            shadowDom: boolean;
            shadowDelegatesFocus: boolean;
            scoped: boolean;
            /**
                * Every component has a render function
                */
            allRenderFn: boolean;
            /**
                * At least one component has a render function
                */
            hasRenderFn: boolean;
            vdomRender: boolean;
            vdomAttribute: boolean;
            vdomClass: boolean;
            vdomFunctional: boolean;
            vdomKey: boolean;
            vdomListener: boolean;
            vdomPropOrAttr: boolean;
            vdomRef: boolean;
            vdomStyle: boolean;
            vdomText: boolean;
            vdomXlink: boolean;
            slotRelocation: boolean;
            slot: boolean;
            svg: boolean;
            element: boolean;
            event: boolean;
            hostListener: boolean;
            hostListenerTargetWindow: boolean;
            hostListenerTargetDocument: boolean;
            hostListenerTargetBody: boolean;
            /**
                * @deprecated Prevented from new apps, but left in for older collections
                */
            hostListenerTargetParent: boolean;
            hostListenerTarget: boolean;
            method: boolean;
            prop: boolean;
            propMutable: boolean;
            state: boolean;
            watchCallback: boolean;
            member: boolean;
            updatable: boolean;
            propBoolean: boolean;
            propNumber: boolean;
            propString: boolean;
            lifecycle: boolean;
            cmpDidLoad: boolean;
            cmpShouldUpdate: boolean;
            cmpWillLoad: boolean;
            cmpDidUpdate: boolean;
            cmpWillUpdate: boolean;
            cmpWillRender: boolean;
            cmpDidRender: boolean;
            cmpDidUnload: boolean;
            connectedCallback: boolean;
            disconnectedCallback: boolean;
            asyncLoading: boolean;
            observeAttribute: boolean;
            reflect: boolean;
            taskQueue: boolean;
    }
    export interface BuildConditionals extends Partial<BuildFeatures> {
            hotModuleReplacement?: boolean;
            isDebug?: boolean;
            isTesting?: boolean;
            isDev?: boolean;
            devTools?: boolean;
            hydrateServerSide?: boolean;
            hydrateClientSide?: boolean;
            lifecycleDOMEvents?: boolean;
            cssAnnotations?: boolean;
            lazyLoad?: boolean;
            profile?: boolean;
            cssVarShim?: boolean;
            constructableCSS?: boolean;
            appendChildSlotFix?: boolean;
            slotChildNodesFix?: boolean;
            cloneNodeFix?: boolean;
            dynamicImportShim?: boolean;
            hydratedAttribute?: boolean;
            hydratedClass?: boolean;
            initializeNextTick?: boolean;
            safari10?: boolean;
            scriptDataOpts?: boolean;
            shadowDomShim?: boolean;
            asyncQueue?: boolean;
            transformTagName?: boolean;
            attachStyles?: boolean;
    }
    export type ModuleFormat = 'amd' | 'cjs' | 'es' | 'iife' | 'system' | 'umd' | 'commonjs' | 'esm' | 'module' | 'systemjs';
    export interface RollupResultModule {
            id: string;
    }
    export interface RollupResults {
            modules: RollupResultModule[];
    }
    export interface BuildCtx {
            buildId: number;
            buildResults: CompilerBuildResults;
            buildMessages: string[];
            bundleBuildCount: number;
            collections: Collection[];
            compilerCtx: CompilerCtx;
            components: ComponentCompilerMeta[];
            componentGraph: Map<string, string[]>;
            config: Config;
            createTimeSpan(msg: string, debug?: boolean): LoggerTimeSpan;
            data: any;
            debug: (msg: string) => void;
            diagnostics: Diagnostic[];
            dirsAdded: string[];
            dirsDeleted: string[];
            entryModules: EntryModule[];
            filesAdded: string[];
            filesChanged: string[];
            filesDeleted: string[];
            filesUpdated: string[];
            filesWritten: string[];
            globalStyle: string | undefined;
            hasConfigChanges: boolean;
            hasError: boolean;
            hasFinished: boolean;
            hasHtmlChanges: boolean;
            hasPrintedResults: boolean;
            hasServiceWorkerChanges: boolean;
            hasScriptChanges: boolean;
            hasStyleChanges: boolean;
            hasWarning: boolean;
            hydrateAppFilePath: string;
            indexBuildCount: number;
            indexDoc: Document;
            isRebuild: boolean;
            moduleFiles: Module[];
            packageJson: PackageJsonData;
            pendingCopyTasks: Promise<CopyResults>[];
            progress(task: BuildTask): void;
            requiresFullBuild: boolean;
            rollupResults?: RollupResults;
            scriptsAdded: string[];
            scriptsDeleted: string[];
            startTime: number;
            styleBuildCount: number;
            stylesPromise: Promise<void>;
            stylesUpdated: BuildStyleUpdate[];
            timeSpan: LoggerTimeSpan;
            timestamp: string;
            transpileBuildCount: number;
            validateTypesBuild?(): Promise<void>;
            validateTypesHandler?: (results: any) => Promise<void>;
            validateTypesPromise?: Promise<any>;
    }
    export interface BuildStyleUpdate {
            styleTag: string;
            styleText: string;
            styleMode: string;
    }
    export type BuildTask = any;
    export type BuildStatus = 'pending' | 'error' | 'disabled' | 'default';
    export interface BuildStats {
            compiler: {
                    name: string;
                    version: string;
            };
            app: {
                    namespace: string;
                    fsNamespace: string;
                    components: number;
                    entries: number;
                    bundles: number;
            };
            options: {
                    minifyJs: boolean;
                    minifyCss: boolean;
                    hashFileNames: boolean;
                    hashedFileNameLength: number;
                    buildEs5: boolean;
            };
            components: BuildComponent[];
            entries: BuildEntry[];
            rollupResults: RollupResults;
            sourceGraph: BuildSourceGraph;
            collections: {
                    name: string;
                    source: string;
                    tags: string[];
            }[];
    }
    export interface BuildEntry {
            entryId: string;
            components: BuildComponent[];
            bundles: BuildBundle[];
            inputs: string[];
            modes?: string[];
            encapsulations: Encapsulation[];
    }
    export interface BuildBundle {
            fileName: string;
            outputs: string[];
            size?: number;
            mode?: string;
            scopedStyles?: boolean;
            target?: string;
    }
    export interface BuildSourceGraph {
            [filePath: string]: string[];
    }
    export interface BuildComponent {
            tag: string;
            dependencyOf?: string[];
            dependencies?: string[];
    }
    export interface BundleOutputChunk {
            code: string;
            fileName: string;
            isDynamicEntry: boolean;
            isEntry: boolean;
            map: any;
            dynamicImports: string[];
            imports: string[];
            exports: string[];
            modules: {
                    [modulePath: string]: {
                            renderedExports: string[];
                            removedExports: string[];
                            renderedLength: number;
                            originalLength: number;
                    };
            };
            name: string;
    }
    export type SourceTarget = 'es5' | 'es2017' | 'latest';
    export interface BundleEntryInputs {
            [entryKey: string]: string;
    }
    export type RollupResult = RollupChunkResult | RollupAssetResult;
    export interface RollupAssetResult {
            type: 'asset';
            fileName: string;
            content: string;
    }
    export interface RollupChunkResult {
            type: 'chunk';
            entryKey: string;
            fileName: string;
            code: string;
            isEntry: boolean;
            isComponent: boolean;
            isCore: boolean;
            isIndex: boolean;
            isBrowserLoader: boolean;
            imports: string[];
            moduleFormat: ModuleFormat;
    }
    export interface BundleModule {
            entryKey: string;
            rollupResult: RollupChunkResult;
            cmps: ComponentCompilerMeta[];
            output: BundleModuleOutput;
    }
    export interface BundleModuleOutput {
            bundleId: string;
            fileName: string;
            code: string;
    }
    export interface Cache {
            get(key: string): Promise<string>;
            put(key: string, value: string): Promise<boolean>;
            has(key: string): Promise<boolean>;
            createKey(domain: string, ...args: any[]): Promise<string>;
            commit(): Promise<void>;
            clear(): void;
            clearDiskCache(): Promise<void>;
            getMemoryStats(): string;
            initCacheDir(): Promise<void>;
    }
    export interface CollectionCompilerMeta {
            collectionName?: string;
            moduleId?: string;
            moduleDir?: string;
            moduleFiles?: Module[];
            global?: Module;
            compiler?: CollectionCompilerVersion;
            isInitialized?: boolean;
            hasExports?: boolean;
            dependencies?: string[];
            bundles?: {
                    components: string[];
            }[];
    }
    export interface CollectionCompilerVersion {
            name: string;
            version: string;
            typescriptVersion?: string;
    }
    export interface CollectionManifest {
            entries?: CollectionComponentEntryPath[];
            collections?: CollectionDependencyManifest[];
            global?: string;
            compiler?: CollectionCompilerVersion;
            bundles?: CollectionBundleManifest[];
    }
    export type CollectionComponentEntryPath = string;
    export interface CollectionBundleManifest {
            components: string[];
    }
    export interface CollectionDependencyManifest {
            name: string;
            tags: string[];
    }
    /** OLD WAY */
    export interface Collection {
            collectionName?: string;
            moduleDir?: string;
            moduleFiles?: any[];
            global?: any;
            compiler?: CollectionCompiler;
            isInitialized?: boolean;
            hasExports?: boolean;
            dependencies?: string[];
            bundles?: {
                    components: string[];
            }[];
    }
    export interface CollectionCompiler {
            name: string;
            version: string;
            typescriptVersion?: string;
    }
    export interface AppRegistry {
            namespace?: string;
            fsNamespace?: string;
            loader?: string;
            core?: string;
            corePolyfilled?: string;
            global?: string;
            components?: AppRegistryComponents;
    }
    export interface AppRegistryComponents {
            [tagName: string]: {
                    bundleIds: ModeBundleIds;
                    encapsulation?: 'shadow' | 'scoped';
            };
    }
    /** OLD WAY */
    export interface ModuleFile {
            sourceFilePath: string;
            jsFilePath?: string;
            dtsFilePath?: string;
            cmpMeta?: any;
            isCollectionDependency?: boolean;
            excludeFromCollection?: boolean;
            originalCollectionComponentPath?: string;
            externalImports?: string[];
            localImports?: string[];
            potentialCmpRefs?: string[];
            hasSlot?: boolean;
            hasSvg?: boolean;
    }
    export interface ModuleBundles {
            [bundleId: string]: string;
    }
    export interface CollectionData {
            components?: ComponentData[];
            collections?: CollectionDependencyData[];
            global?: string;
            modules?: string[];
            compiler?: {
                    name: string;
                    version: string;
                    typescriptVersion?: string;
            };
            bundles?: CollectionBundle[];
    }
    export interface CollectionBundle {
            components: string[];
    }
    export interface CollectionDependencyData {
            name: string;
            tags: string[];
    }
    export interface ComponentData {
            tag?: string;
            componentPath?: string;
            componentClass?: string;
            dependencies?: string[];
            styles?: StylesData;
            props?: PropData[];
            states?: StateData[];
            listeners?: ListenerData[];
            methods?: MethodData[];
            events?: EventData[];
            connect?: ConnectData[];
            context?: ContextData[];
            hostElement?: HostElementData;
            host?: any;
            assetPaths?: string[];
            slot?: 'hasSlots' | 'hasNamedSlots';
            shadow?: boolean;
            scoped?: boolean;
            priority?: 'low';
    }
    export interface StylesData {
            [modeName: string]: StyleData;
    }
    export interface StyleData {
            stylePaths?: string[];
            style?: string;
    }
    export interface PropData {
            name?: string;
            type?: 'Boolean' | 'Number' | 'String' | 'Any';
            mutable?: boolean;
            attr?: string;
            reflectToAttr?: boolean;
            watch?: string[];
    }
    export interface StateData {
            name: string;
    }
    export interface ListenerData {
            event: string;
            method: string;
            capture?: boolean;
            passive?: boolean;
            enabled?: boolean;
    }
    export interface MethodData {
            name: string;
    }
    export interface EventData {
            event: string;
            method?: string;
            bubbles?: boolean;
            cancelable?: boolean;
            composed?: boolean;
    }
    export interface ConnectData {
            name: string;
            tag?: string;
    }
    export interface ContextData {
            name: string;
            id?: string;
    }
    export interface HostElementData {
            name: string;
    }
    export interface BuildOutputFile {
            name: string;
            content: string;
    }
    export type OnCallback = (buildStart: CompilerBuildStart) => void;
    export type RemoveCallback = () => boolean;
    export interface CompilerCtx {
            version: number;
            activeBuildId: number;
            activeDirsAdded: string[];
            activeDirsDeleted: string[];
            activeFilesAdded: string[];
            activeFilesDeleted: string[];
            activeFilesUpdated: string[];
            addWatchDir: (path: string, recursive: boolean) => void;
            addWatchFile: (path: string) => void;
            cache: Cache;
            cssModuleImports: Map<string, string[]>;
            cachedGlobalStyle: string;
            collections: CollectionCompilerMeta[];
            compilerOptions: any;
            events: BuildEvents;
            fs: InMemoryFileSystem;
            hasSuccessfulBuild: boolean;
            isActivelyBuilding: boolean;
            lastBuildResults: CompilerBuildResults;
            moduleMap: ModuleMap;
            nodeMap: NodeMap;
            resolvedCollections: Set<string>;
            rollupCacheHydrate: any;
            rollupCacheLazy: any;
            rollupCacheNative: any;
            styleModeNames: Set<string>;
            changedModules: Set<string>;
            changedFiles: Set<string>;
            worker?: CompilerWorkerContext;
            rollupCache: Map<string, any>;
            reset(): void;
    }
    export type NodeMap = WeakMap<any, ComponentCompilerMeta>;
    /** Must be serializable to JSON!! */
    export interface ComponentCompilerFeatures {
            hasAttribute: boolean;
            hasAttributeChangedCallbackFn: boolean;
            hasComponentWillLoadFn: boolean;
            hasComponentDidLoadFn: boolean;
            hasComponentShouldUpdateFn: boolean;
            hasComponentWillUpdateFn: boolean;
            hasComponentDidUpdateFn: boolean;
            hasComponentWillRenderFn: boolean;
            hasComponentDidRenderFn: boolean;
            hasComponentDidUnloadFn: boolean;
            hasConnectedCallbackFn: boolean;
            hasDisconnectedCallbackFn: boolean;
            hasElement: boolean;
            hasEvent: boolean;
            hasLifecycle: boolean;
            hasListener: boolean;
            hasListenerTarget: boolean;
            hasListenerTargetWindow: boolean;
            hasListenerTargetDocument: boolean;
            hasListenerTargetBody: boolean;
            /**
                * @deprecated Prevented from new apps, but left in for older collections
                */
            hasListenerTargetParent: boolean;
            hasMember: boolean;
            hasMethod: boolean;
            hasMode: boolean;
            hasProp: boolean;
            hasPropBoolean: boolean;
            hasPropNumber: boolean;
            hasPropString: boolean;
            hasPropMutable: boolean;
            hasReflect: boolean;
            hasRenderFn: boolean;
            hasState: boolean;
            hasStyle: boolean;
            hasVdomAttribute: boolean;
            hasVdomClass: boolean;
            hasVdomFunctional: boolean;
            hasVdomKey: boolean;
            hasVdomListener: boolean;
            hasVdomPropOrAttr: boolean;
            hasVdomRef: boolean;
            hasVdomRender: boolean;
            hasVdomStyle: boolean;
            hasVdomText: boolean;
            hasVdomXlink: boolean;
            hasWatchCallback: boolean;
            htmlAttrNames: string[];
            htmlTagNames: string[];
            htmlParts: string[];
            isUpdateable: boolean;
            isPlain: boolean;
            potentialCmpRefs: string[];
    }
    /** Must be serializable to JSON!! */
    export interface ComponentCompilerMeta extends ComponentCompilerFeatures {
            assetsDirs: CompilerAssetDir[];
            componentClassName: string;
            elementRef: string;
            encapsulation: Encapsulation;
            shadowDelegatesFocus: boolean;
            excludeFromCollection: boolean;
            isCollectionDependency: boolean;
            docs: CompilerJsDoc;
            jsFilePath: string;
            listeners: ComponentCompilerListener[];
            events: ComponentCompilerEvent[];
            methods: ComponentCompilerMethod[];
            virtualProperties: ComponentCompilerVirtualProperty[];
            properties: ComponentCompilerProperty[];
            watchers: ComponentCompilerWatch[];
            sourceFilePath: string;
            states: ComponentCompilerState[];
            styleDocs: CompilerStyleDoc[];
            styles: StyleCompiler[];
            tagName: string;
            internal: boolean;
            legacyConnect: ComponentCompilerLegacyConnect[];
            legacyContext: ComponentCompilerLegacyContext[];
            dependencies?: string[];
            dependents?: string[];
            directDependencies?: string[];
            directDependents?: string[];
    }
    export interface ComponentCompilerLegacyConnect {
            name: string;
            connect: string;
    }
    export interface ComponentCompilerLegacyContext {
            name: string;
            context: string;
    }
    export type Encapsulation = 'shadow' | 'scoped' | 'none';
    export interface ComponentCompilerStaticProperty {
            mutable: boolean;
            optional: boolean;
            required: boolean;
            type: ComponentCompilerPropertyType;
            complexType: ComponentCompilerPropertyComplexType;
            attribute?: string;
            reflect?: boolean;
            docs: CompilerJsDoc;
            defaultValue?: string;
    }
    export interface ComponentCompilerProperty extends ComponentCompilerStaticProperty {
            name: string;
            internal: boolean;
    }
    export interface ComponentCompilerVirtualProperty {
            name: string;
            type: string;
            docs: string;
    }
    export type ComponentCompilerPropertyType = 'any' | 'string' | 'boolean' | 'number' | 'unknown';
    export interface ComponentCompilerPropertyComplexType {
            original: string;
            resolved: string;
            references: ComponentCompilerTypeReferences;
    }
    export interface ComponentCompilerTypeReferences {
            [key: string]: ComponentCompilerTypeReference;
    }
    export interface ComponentCompilerTypeReference {
            location: 'local' | 'global' | 'import';
            path?: string;
    }
    export interface ComponentCompilerStaticEvent {
            name: string;
            method: string;
            bubbles: boolean;
            cancelable: boolean;
            composed: boolean;
            docs: CompilerJsDoc;
            complexType: ComponentCompilerEventComplexType;
    }
    export interface ComponentCompilerEvent extends ComponentCompilerStaticEvent {
            internal: boolean;
    }
    export interface ComponentCompilerEventComplexType {
            original: string;
            resolved: string;
            references: ComponentCompilerTypeReferences;
    }
    export interface ComponentCompilerListener {
            name: string;
            method: string;
            capture: boolean;
            passive: boolean;
            target: ListenTargetOptions | undefined;
    }
    export interface ComponentCompilerStaticMethod {
            docs: CompilerJsDoc;
            complexType: ComponentCompilerMethodComplexType;
    }
    export interface ComponentCompilerMethodComplexType {
            signature: string;
            parameters: CompilerJsDoc[];
            references: ComponentCompilerTypeReferences;
            return: string;
    }
    export interface ComponentCompilerWatch {
            propName: string;
            methodName: string;
    }
    export interface ComponentCompilerMethod extends ComponentCompilerStaticMethod {
            name: string;
            internal: boolean;
    }
    export interface ComponentCompilerState {
            name: string;
    }
    export interface CompilerJsDoc {
            text: string;
            tags: CompilerJsDocTagInfo[];
    }
    export interface CompilerJsDocTagInfo {
            name: string;
            text?: string;
    }
    export interface CompilerStyleDoc {
            name: string;
            docs: string;
            annotation: 'prop';
    }
    export interface CompilerAssetDir {
            absolutePath?: string;
            cmpRelativePath?: string;
            originalComponentPath?: string;
    }
    export interface ComponentCompilerData {
            exportLine: string;
            filePath: string;
            cmp: ComponentCompilerMeta;
            uniqueComponentClassName?: string;
            importLine?: string;
    }
    export interface ComponentConstructor {
            is?: string;
            properties?: ComponentConstructorProperties;
            watchers?: ComponentConstructorWatchers;
            events?: ComponentConstructorEvent[];
            listeners?: ComponentConstructorListener[];
            style?: string;
            styleId?: string;
            encapsulation?: ComponentConstructorEncapsulation;
            observedAttributes?: string[];
            cmpMeta?: ComponentRuntimeMeta;
            isProxied?: boolean;
            isStyleRegistered?: boolean;
    }
    export interface ComponentConstructorWatchers {
            [propName: string]: string[];
    }
    export interface ComponentTestingConstructor extends ComponentConstructor {
            COMPILER_META: ComponentCompilerMeta;
            prototype?: {
                    componentWillLoad?: Function;
                    componentWillUpdate?: Function;
                    componentWillRender?: Function;
                    __componentWillLoad?: Function;
                    __componentWillUpdate?: Function;
                    __componentWillRender?: Function;
            };
    }
    export interface ComponentNativeConstructor extends ComponentConstructor {
            cmpMeta: ComponentRuntimeMeta;
    }
    export type ComponentConstructorEncapsulation = 'shadow' | 'scoped' | 'none';
    export interface ComponentConstructorProperties {
            [propName: string]: ComponentConstructorProperty;
    }
    export interface ComponentConstructorProperty {
            attribute?: string;
            elementRef?: boolean;
            method?: boolean;
            mutable?: boolean;
            reflect?: boolean;
            state?: boolean;
            type?: ComponentConstructorPropertyType;
            watchCallbacks?: string[];
    }
    export type ComponentConstructorPropertyType = StringConstructor | BooleanConstructor | NumberConstructor | 'string' | 'boolean' | 'number';
    export interface ComponentConstructorEvent {
            name: string;
            method: string;
            bubbles: boolean;
            cancelable: boolean;
            composed: boolean;
    }
    export interface ComponentConstructorListener {
            name: string;
            method: string;
            capture?: boolean;
            passive?: boolean;
    }
    export interface HostConfig {
            hosting?: {
                    rules?: HostRule[];
            };
    }
    export interface HostRule {
            include: string;
            headers: HostRuleHeader[];
    }
    export interface HostRuleHeader {
            name?: string;
            value?: string;
    }
    export interface CssVarShim {
            i(): Promise<any>;
            addLink(linkEl: HTMLLinkElement): Promise<any>;
            addGlobalStyle(styleEl: HTMLStyleElement): void;
            createHostStyle(hostEl: HTMLElement, templateName: string, cssText: string, isScoped: boolean): HTMLStyleElement;
            removeHost(hostEl: HTMLElement): void;
            updateHost(hostEl: HTMLElement): void;
            updateGlobal(): void;
    }
    export interface DevClientWindow extends Window {
            ['s-dev-server']: boolean;
            ['s-initial-load']: boolean;
            ['s-build-id']: number;
            WebSocket: new (socketUrl: string, protos: string[]) => WebSocket;
            devServerConfig?: DevClientConfig;
    }
    export interface DevClientConfig {
            basePath: string;
            editors: DevServerEditor[];
            reloadStrategy: PageReloadStrategy;
            socketUrl?: string;
    }
    export interface HttpRequest {
            method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'OPTIONS';
            acceptHeader: string;
            url: URL;
            searchParams: URLSearchParams;
            pathname?: string;
            filePath?: string;
            stats?: CompilerFsStats;
            headers?: {
                    [name: string]: string;
            };
            host?: string;
    }
    export interface DevServerMessage {
            startServer?: DevServerConfig;
            closeServer?: boolean;
            serverStarted?: DevServerConfig;
            serverClosed?: boolean;
            buildStart?: boolean;
            buildLog?: BuildLog;
            buildResults?: CompilerBuildResults;
            requestBuildResults?: boolean;
            error?: {
                    message?: string;
                    type?: string;
                    stack?: any;
            };
            isActivelyBuilding?: boolean;
            compilerRequestPath?: string;
            compilerRequestResults?: CompilerRequestResponse;
            requestLog?: {
                    method: string;
                    url: string;
                    status: number;
            };
    }
    export type DevServerSendMessage = (msg: DevServerMessage) => void;
    export interface DevServerContext {
            connectorHtml: string;
            dirTemplate: string;
            getBuildResults: () => Promise<CompilerBuildResults>;
            getCompilerRequest: (path: string) => Promise<CompilerRequestResponse>;
            isServerListening: boolean;
            logRequest: (req: {
                    method: string;
                    pathname?: string;
            }, status: number) => void;
            prerenderConfig: PrerenderConfig;
            serve302: (req: any, res: any, pathname?: string) => void;
            serve404: (req: any, res: any, xSource: string, content?: string) => void;
            serve500: (req: any, res: any, error: any, xSource: string) => void;
            sys: CompilerSystem;
    }
    export type InitServerProcess = (sendMsg: (msg: DevServerMessage) => void) => (msg: DevServerMessage) => void;
    export interface DevResponseHeaders {
            'cache-control'?: string;
            'expires'?: string;
            'content-type'?: string;
            'content-length'?: number;
            'date'?: string;
            'access-control-allow-origin'?: string;
            'access-control-expose-headers'?: string;
            'content-encoding'?: 'gzip';
            'vary'?: 'Accept-Encoding';
            'server'?: string;
            'x-directory-index'?: string;
            'x-source'?: string;
    }
    export interface OpenInEditorData {
            file?: string;
            line?: number;
            column?: number;
            open?: string;
            editor?: string;
            exists?: boolean;
            error?: string;
    }
    export interface EntryModule {
            entryKey: string;
            cmps: ComponentCompilerMeta[];
    }
    export interface EntryBundle {
            fileName: string;
            text: string;
            outputs: string[];
            modeName: string;
            isScopedStyles: boolean;
            sourceTarget: string;
    }
    export interface EntryComponent {
            tag: string;
            dependencyOf?: string[];
    }
    export interface ComponentRef {
            tag: string;
            filePath: string;
    }
    export interface ModuleGraph {
            filePath: string;
            importPaths: string[];
    }
    export interface AddEventListener {
            (elm: Element | Document | Window, eventName: string, cb: EventListenerCallback, opts?: ListenOptions): Function;
    }
    export interface EventListenerCallback {
            (ev?: any): void;
    }
    export interface EventEmitterData<T = any> {
            detail?: T;
            bubbles?: boolean;
            cancelable?: boolean;
            composed?: boolean;
    }
    export interface FsReadOptions {
            useCache?: boolean;
            setHash?: boolean;
    }
    export interface FsReaddirOptions {
            inMemoryOnly?: boolean;
            recursive?: boolean;
            /**
                * Directory names to exclude. Just the basename,
                * not the entire path. Basically for "node_moduels".
                */
            excludeDirNames?: string[];
            /**
                * Extensions we know we can avoid. Each extension
                * should include the `.` so that we can test for both
                * `.d.ts.` and `.ts`. If `excludeExtensions` isn't provided it
                * doesn't try to exclude anything. This only checks against
                * the filename, not directory names when recursive.
                */
            excludeExtensions?: string[];
    }
    export interface FsReaddirItem {
            absPath: string;
            relPath: string;
            isDirectory: boolean;
            isFile: boolean;
    }
    export interface FsWriteResults {
            changedContent: boolean;
            queuedWrite: boolean;
            ignored: boolean;
    }
    export type FsItems = Map<string, FsItem>;
    export interface FsItem {
            fileText: string;
            isFile: boolean;
            isDirectory: boolean;
            size: number;
            mtimeMs: number;
            exists: boolean;
            queueCopyFileToDest: string;
            queueWriteToDisk: boolean;
            queueDeleteFromDisk?: boolean;
            useCache: boolean;
    }
    export interface HostElement extends HTMLElement {
            connectedCallback?: () => void;
            attributeChangedCallback?: (attribName: string, oldVal: string, newVal: string, namespace: string) => void;
            disconnectedCallback?: () => void;
            host?: Element;
            forceUpdate?: () => void;
            /**
                * Unique stencil id for this element
                */
            ['s-id']?: string;
            /**
                * Content Reference:
                * Reference to the HTML Comment that's placed inside of the
                * host element's original content. This comment is used to
                * always represent where host element's light dom is.
                */
            ['s-cr']?: RenderNode;
            /**
                * Lifecycle ready
                */
            ['s-lr']?: boolean;
            /**
                * On Render Callbacks:
                * Array of callbacks to fire off after it has rendered.
                */
            ['s-rc']?: (() => void)[];
            /**
                * Scope Id
                * The scope id of this component when using scoped css encapsulation
                * or using shadow dom but the browser doesn't support it
                */
            ['s-sc']?: string;
            /**
                * Hot Module Replacement, dev mode only
                */
            ['s-hmr']?: (versionId: string) => void;
            /**
                * Callback method for when HMR finishes
                */
            ['s-hmr-load']?: () => void;
            ['s-p']?: Promise<void>[];
            componentOnReady?: () => Promise<this>;
    }
    export interface InMemoryFileSystem {
            sys?: CompilerSystem;
            accessData(filePath: string): Promise<{
                    exists: boolean;
                    isDirectory: boolean;
                    isFile: boolean;
            }>;
            access(filePath: string): Promise<boolean>;
            /**
                * Synchronous!!! Do not use!!!
                * (Only typescript transpiling is allowed to use)
                * @param filePath
                */
            accessSync(filePath: string): boolean;
            copyFile(srcFile: string, dest: string): Promise<void>;
            emptyDirs(dirPaths: string[]): Promise<void>;
            readdir(dirPath: string, opts?: FsReaddirOptions): Promise<FsReaddirItem[]>;
            readFile(filePath: string, opts?: FsReadOptions): Promise<string>;
            /**
                * Synchronous!!! Do not use!!!
                * (Only typescript transpiling is allowed to use)
                * @param filePath
                */
            readFileSync(filePath: string, opts?: FsReadOptions): string;
            remove(itemPath: string): Promise<void>;
            stat(itemPath: string): Promise<{
                    isFile: boolean;
                    isDirectory: boolean;
            }>;
            /**
                * Synchronous!!! Do not use!!!
                * (Only typescript transpiling is allowed to use)
                * @param itemPath
                */
            statSync(itemPath: string): {
                    exists: boolean;
                    isFile: boolean;
                    isDirectory: boolean;
            };
            writeFile(filePath: string, content: string, opts?: FsWriteOptions): Promise<FsWriteResults>;
            writeFiles(files: {
                    [filePath: string]: string;
            } | Map<string, String>, opts?: FsWriteOptions): Promise<FsWriteResults[]>;
            commit(): Promise<{
                    filesWritten: string[];
                    filesDeleted: string[];
                    filesCopied: string[][];
                    dirsDeleted: string[];
                    dirsAdded: string[];
            }>;
            cancelDeleteFilesFromDisk(filePaths: string[]): void;
            cancelDeleteDirectoriesFromDisk(filePaths: string[]): void;
            clearDirCache(dirPath: string): void;
            clearFileCache(filePath: string): void;
            getItem(itemPath: string): FsItem;
            getBuildOutputs(): BuildOutput[];
            clearCache(): void;
            keys(): string[];
            getMemoryStats(): string;
    }
    export interface HydrateResults {
            buildId: string;
            diagnostics: Diagnostic[];
            url: string;
            host: string;
            hostname: string;
            href: string;
            port: string;
            pathname: string;
            search: string;
            hash: string;
            html: string;
            components: HydrateComponent[];
            anchors: HydrateAnchorElement[];
            imgs: HydrateImgElement[];
            scripts: HydrateScriptElement[];
            styles: HydrateStyleElement[];
            staticData: HydrateStaticData[];
            title: string;
            hydratedCount: number;
            httpStatus: number;
    }
    export interface HydrateComponent {
            tag: string;
            mode: string;
            count: number;
            depth: number;
    }
    export interface HydrateElement {
            [attrName: string]: string | undefined;
    }
    export interface HydrateAnchorElement extends HydrateElement {
            href?: string;
            target?: string;
    }
    export interface HydrateImgElement extends HydrateElement {
            src?: string;
    }
    export interface HydrateScriptElement extends HydrateElement {
            src?: string;
            type?: string;
    }
    export interface HydrateStyleElement extends HydrateElement {
            href?: string;
    }
    export interface HydrateStaticData {
            id: string;
            type: string;
            content: string;
    }
    export interface JsDoc {
            name: string;
            documentation: string;
            type: string;
            tags: JSDocTagInfo[];
            default?: string;
            parameters?: JsDoc[];
            returns?: {
                    type: string;
                    documentation: string;
            };
    }
    export interface JSDocTagInfo {
            name: string;
            text?: string;
    }
    export interface MinifyJsResult {
            code: string;
            sourceMap: any;
            error: {
                    message: string;
                    filename: string;
                    line: number;
                    col: number;
                    pos: number;
            };
    }
    export type ModuleMap = Map<string, Module>;
    /**
        * Module gets serialized/parsed as JSON
        * cannot use Map or Set
        */
    export interface Module {
            cmps: ComponentCompilerMeta[];
            coreRuntimeApis: string[];
            collectionName: string;
            dtsFilePath: string;
            excludeFromCollection: boolean;
            externalImports: string[];
            htmlAttrNames: string[];
            htmlTagNames: string[];
            htmlParts: string[];
            isCollectionDependency: boolean;
            isLegacy: boolean;
            jsFilePath: string;
            localImports: string[];
            originalImports: string[];
            originalCollectionComponentPath: string;
            potentialCmpRefs: string[];
            sourceFilePath: string;
            staticSourceFile: any;
            staticSourceFileText: string;
            hasVdomAttribute: boolean;
            hasVdomClass: boolean;
            hasVdomFunctional: boolean;
            hasVdomKey: boolean;
            hasVdomListener: boolean;
            hasVdomPropOrAttr: boolean;
            hasVdomRef: boolean;
            hasVdomRender: boolean;
            hasVdomStyle: boolean;
            hasVdomText: boolean;
            hasVdomXlink: boolean;
    }
    export interface Plugin {
            name?: string;
            pluginType?: string;
            load?: (id: string, context: PluginCtx) => Promise<string> | string;
            resolveId?: (importee: string, importer: string, context: PluginCtx) => Promise<string> | string;
            transform?: (sourceText: string, id: string, context: PluginCtx) => Promise<PluginTransformResults> | PluginTransformResults | string;
    }
    export interface PluginTransformResults {
            code?: string;
            map?: string;
            id?: string;
            diagnostics?: Diagnostic[];
            dependencies?: string[];
    }
    export interface PluginCtx {
            config: Config;
            sys: CompilerSystem;
            fs: InMemoryFileSystem;
            cache: Cache;
            diagnostics: Diagnostic[];
    }
    export interface PrerenderUrlResults {
            anchorUrls: string[];
            diagnostics: Diagnostic[];
            filePath: string;
    }
    export interface PrerenderUrlRequest {
            appDir: string;
            buildId: string;
            baseUrl: string;
            componentGraphPath: string;
            devServerHostUrl: string;
            hydrateAppFilePath: string;
            isDebug: boolean;
            prerenderConfigPath: string;
            staticSite: boolean;
            templateId: string;
            url: string;
            writeToFilePath: string;
    }
    export interface PrerenderManager {
            config: Config;
            prerenderUrlWorker: (prerenderRequest: PrerenderUrlRequest) => Promise<PrerenderUrlResults>;
            devServerHostUrl: string;
            diagnostics: Diagnostic[];
            hydrateAppFilePath: string;
            isDebug: boolean;
            logCount: number;
            outputTarget: OutputTargetWww;
            prerenderConfig: PrerenderConfig;
            prerenderConfigPath: string;
            progressLogger?: LoggerLineUpdater;
            resolve: Function;
            staticSite: boolean;
            templateId: string;
            componentGraphPath: string;
            urlsProcessing: Set<string>;
            urlsPending: Set<string>;
            urlsCompleted: Set<string>;
            maxConcurrency: number;
    }
    /**
        * Generic node that represents all of the
        * different types of nodes we'd see when rendering
        */
    export interface RenderNode extends HostElement {
            /**
                * Shadow root's host
                */
            host?: Element;
            /**
                * Is Content Reference Node:
                * This node is a content reference node.
                */
            ['s-cn']?: boolean;
            /**
                * Is a slot reference node:
                * This is a node that represents where a slots
                * was originally located.
                */
            ['s-sr']?: boolean;
            /**
                * Slot name
                */
            ['s-sn']?: string;
            /**
                * Host element tag name:
                * The tag name of the host element that this
                * node was created in.
                */
            ['s-hn']?: string;
            /**
                * Original Location Reference:
                * A reference pointing to the comment
                * which represents the original location
                * before it was moved to its slot.
                */
            ['s-ol']?: RenderNode;
            /**
                * Node reference:
                * This is a reference for a original location node
                * back to the node that's been moved around.
                */
            ['s-nr']?: RenderNode;
            /**
                * Scope Id
                */
            ['s-si']?: string;
            /**
                * Host Id (hydrate only)
                */
            ['s-host-id']?: number;
            /**
                * Node Id (hydrate only)
                */
            ['s-node-id']?: number;
            /**
                * Used to know the components encapsulation.
                * empty "" for shadow, "c" from scoped
                */
            ['s-en']?: '' | /*shadow*/ 'c';
    }
    export type LazyBundlesRuntimeData = LazyBundleRuntimeData[];
    export type LazyBundleRuntimeData = [
            /** bundleIds */
            string,
            ComponentRuntimeMetaCompact[]
    ];
    export type ComponentRuntimeMetaCompact = [
            /** flags */
            number,
            /** tagname */
            string,
            /** members */
            {
                    [memberName: string]: ComponentRuntimeMember;
            }?,
            /** listeners */
            ComponentRuntimeHostListener[]?
    ];
    export interface ComponentRuntimeMeta {
            $flags$: number;
            $tagName$: string;
            $members$?: ComponentRuntimeMembers;
            $listeners$?: ComponentRuntimeHostListener[];
            $attrsToReflect$?: [string, string][];
            $watchers$?: ComponentConstructorWatchers;
            $lazyBundleId$?: string;
    }
    export interface ComponentRuntimeMembers {
            [memberName: string]: ComponentRuntimeMember;
    }
    export type ComponentRuntimeMember = [
            /**
                * flags data
                */
            number,
            /**
                * attribute name to observe
                */
            string?
    ];
    export type ComponentRuntimeHostListener = [
            /**
                * event flags
                */
            number,
            /**
                * event name,
                */
            string,
            /**
                * event method,
                */
            string
    ];
    export type ModeBundleId = ModeBundleIds | string;
    export interface ModeBundleIds {
            [modeName: string]: string;
    }
    export type RuntimeRef = HostElement | {};
    export interface HostRef {
            $ancestorComponent$?: HostElement;
            $flags$: number;
            $cmpMeta$: ComponentRuntimeMeta;
            $hostElement$?: HostElement;
            $instanceValues$?: Map<string, any>;
            $lazyInstance$?: ComponentInterface;
            $onReadyPromise$?: Promise<any>;
            $onReadyResolve$?: (elm: any) => void;
            $onInstancePromise$?: Promise<any>;
            $onInstanceResolve$?: (elm: any) => void;
            $onRenderResolve$?: () => void;
            $vnode$?: VNode;
            $queuedListeners$?: [string, any][];
            $rmListeners$?: (() => void)[];
            $modeName$?: string;
            $renderCount$?: number;
    }
    export interface PlatformRuntime {
            $cssShim$?: CssVarShim;
            $flags$: number;
            $orgLocNodes$?: Map<string, RenderNode>;
            $resourcesUrl$: string;
            jmp: (c: Function) => any;
            raf: (c: FrameRequestCallback) => number;
            ael: (el: EventTarget, eventName: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions) => void;
            rel: (el: EventTarget, eventName: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions) => void;
            ce: (eventName: string, opts?: any) => CustomEvent;
    }
    export type RefMap = WeakMap<any, HostRef>;
    export type StyleMap = Map<string, CSSStyleSheet | string>;
    export type RootAppliedStyleMap = WeakMap<Element, Set<string>>;
    export type AppliedStyleMap = Set<string>;
    export type ActivelyProcessingCmpMap = Set<Element>;
    export interface ScreenshotConnector {
            initBuild(opts: ScreenshotConnectorOptions): Promise<void>;
            completeBuild(masterBuild: ScreenshotBuild): Promise<ScreenshotBuildResults>;
            getMasterBuild(): Promise<ScreenshotBuild>;
            pullMasterBuild(): Promise<void>;
            publishBuild(buildResults: ScreenshotBuildResults): Promise<ScreenshotBuildResults>;
            getScreenshotCache(): Promise<ScreenshotCache>;
            updateScreenshotCache(screenshotCache: ScreenshotCache, buildResults: ScreenshotBuildResults): Promise<ScreenshotCache>;
            generateJsonpDataUris(build: ScreenshotBuild): Promise<void>;
            sortScreenshots(screenshots: Screenshot[]): Screenshot[];
            toJson(masterBuild: ScreenshotBuild, screenshotCache: ScreenshotCache): string;
    }
    export interface ScreenshotBuildResults {
            appNamespace: string;
            masterBuild: ScreenshotBuild;
            currentBuild: ScreenshotBuild;
            compare: ScreenshotCompareResults;
    }
    export interface ScreenshotCompareResults {
            id: string;
            a: {
                    id: string;
                    message: string;
                    author: string;
                    url: string;
                    previewUrl: string;
            };
            b: {
                    id: string;
                    message: string;
                    author: string;
                    url: string;
                    previewUrl: string;
            };
            timestamp: number;
            url: string;
            appNamespace: string;
            diffs: ScreenshotDiff[];
    }
    export interface ScreenshotConnectorOptions {
            buildId: string;
            buildMessage: string;
            buildAuthor?: string;
            buildUrl?: string;
            previewUrl?: string;
            appNamespace: string;
            buildTimestamp: number;
            logger: Logger;
            rootDir: string;
            cacheDir: string;
            packageDir: string;
            screenshotDirName?: string;
            imagesDirName?: string;
            buildsDirName?: string;
            currentBuildDir?: string;
            updateMaster?: boolean;
            allowableMismatchedPixels?: number;
            allowableMismatchedRatio?: number;
            pixelmatchThreshold?: number;
            waitBeforeScreenshot?: number;
            pixelmatchModulePath?: string;
    }
    export interface ScreenshotBuildData {
            buildId: string;
            rootDir: string;
            screenshotDir: string;
            imagesDir: string;
            buildsDir: string;
            currentBuildDir: string;
            updateMaster: boolean;
            allowableMismatchedPixels: number;
            allowableMismatchedRatio: number;
            pixelmatchThreshold: number;
            masterScreenshots: {
                    [screenshotId: string]: string;
            };
            cache: {
                    [cacheKey: string]: number;
            };
            timeoutBeforeScreenshot: number;
            pixelmatchModulePath: string;
    }
    export interface PixelMatchInput {
            imageAPath: string;
            imageBPath: string;
            width: number;
            height: number;
            pixelmatchThreshold: number;
    }
    export interface ScreenshotBuild {
            id: string;
            message: string;
            author?: string;
            url?: string;
            previewUrl?: string;
            appNamespace: string;
            timestamp: number;
            screenshots: Screenshot[];
    }
    export interface ScreenshotCache {
            timestamp?: number;
            lastBuildId?: string;
            size?: number;
            items?: {
                    /**
                        * Cache key
                        */
                    key: string;
                    /**
                        * Timestamp used to remove the oldest data
                        */
                    ts: number;
                    /**
                        * Mismatched pixels
                        */
                    mp: number;
            }[];
    }
    export interface Screenshot {
            id: string;
            desc?: string;
            image: string;
            device?: string;
            userAgent?: string;
            width?: number;
            height?: number;
            deviceScaleFactor?: number;
            hasTouch?: boolean;
            isLandscape?: boolean;
            isMobile?: boolean;
            testPath?: string;
            diff?: ScreenshotDiff;
    }
    export interface ScreenshotDiff {
            mismatchedPixels: number;
            id?: string;
            desc?: string;
            imageA?: string;
            imageB?: string;
            device?: string;
            userAgent?: string;
            width?: number;
            height?: number;
            deviceScaleFactor?: number;
            hasTouch?: boolean;
            isLandscape?: boolean;
            isMobile?: boolean;
            allowableMismatchedPixels: number;
            allowableMismatchedRatio: number;
            testPath?: string;
            cacheKey?: string;
    }
    export interface ScreenshotOptions {
            /**
                * When true, takes a screenshot of the full scrollable page.
                * Default: `false`
                */
            fullPage?: boolean;
            /**
                * An object which specifies clipping region of the page.
                */
            clip?: ScreenshotBoundingBox;
            /**
                * Hides default white background and allows capturing screenshots with transparency.
                * Default: `false`
                */
            omitBackground?: boolean;
            /**
                * Matching threshold, ranges from `0` to 1. Smaller values make the comparison
                * more sensitive. Defaults to the testing config `pixelmatchThreshold` value;
                */
            pixelmatchThreshold?: number;
    }
    export interface ScreenshotBoundingBox {
            /**
                * The x-coordinate of top-left corner.
                */
            x: number;
            /**
                * The y-coordinate of top-left corner.
                */
            y: number;
            /**
                * The width in pixels.
                */
            width: number;
            /**
                * The height in pixels.
                */
            height: number;
    }
    export interface ServerConfigInput {
            app: ExpressApp;
            configPath?: string;
    }
    export interface ServerConfigOutput {
            config: Config;
            logger: Logger;
            wwwDir: string;
            destroy?: () => void;
    }
    export interface ExpressApp {
            use?: Function;
    }
    export interface MiddlewareConfig {
            config: string | Config;
            destroy?: () => void;
    }
    export interface StyleCompiler {
            modeName: string;
            styleId: string;
            styleStr: string;
            styleIdentifier: string;
            externalStyles: ExternalStyleCompiler[];
    }
    export interface ExternalStyleCompiler {
            absolutePath: string;
            relativePath: string;
            originalComponentPath: string;
    }
    export interface CompilerModeStyles {
            [modeName: string]: string[];
    }
    export interface CssImportData {
            srcImport: string;
            updatedImport?: string;
            url: string;
            filePath?: string;
            altFilePath?: string;
            styleText?: string;
    }
    export interface CssToEsmImportData {
            srcImportText: string;
            varName: string;
            url: string;
            filePath: string;
    }
    export interface TransformCssToEsmInput {
            input: string;
            module?: 'cjs' | 'esm' | string;
            file?: string;
            tag?: string;
            encapsulation?: string;
            mode?: string;
            commentOriginalSelector?: boolean;
            sourceMap?: boolean;
            minify?: boolean;
            docs?: boolean;
            autoprefixer?: any;
            styleImportData?: string;
    }
    export interface TransformCssToEsmOutput {
            styleText: string;
            output: string;
            map: any;
            diagnostics: Diagnostic[];
            defaultVarName: string;
            styleDocs: StyleDoc[];
            imports: {
                    varName: string;
                    importPath: string;
            }[];
    }
    export interface PackageJsonData {
            'name'?: string;
            'version'?: string;
            'main'?: string;
            'description'?: string;
            'bin'?: {
                    [key: string]: string;
            };
            'browser'?: string;
            'module'?: string;
            'jsnext:main'?: string;
            'collection:main'?: string;
            'unpkg'?: string;
            'collection'?: string;
            'types'?: string;
            'files'?: string[];
            ['dist-tags']?: {
                    latest: string;
            };
            'dependencies'?: {
                    [moduleId: string]: string;
            };
            'devDependencies'?: {
                    [moduleId: string]: string;
            };
            'repository'?: {
                    type?: string;
                    url?: string;
            };
            'private'?: boolean;
            'scripts'?: {
                    [runName: string]: string;
            };
            'license'?: string;
            'keywords'?: string[];
    }
    export interface Workbox {
            generateSW(swConfig: any): Promise<any>;
            generateFileManifest(): Promise<any>;
            getFileManifestEntries(): Promise<any>;
            injectManifest(swConfig: any): Promise<any>;
            copyWorkboxLibraries(wwwDir: string): Promise<any>;
    }
    export interface Url {
            href?: string;
            protocol?: string;
            auth?: string;
            hostname?: string;
            host?: string;
            port?: string;
            pathname?: string;
            path?: string;
            search?: string;
            query?: string | any;
            hash?: string;
    }
    global {
            namespace jest {
                    interface Matchers<R, T> {
                            /**
                                * Compares HTML, but first normalizes the HTML so all
                                * whitespace, attribute order and css class order are
                                * the same. When given an element, it will compare
                                * the element's `outerHTML`. When given a Document Fragment,
                                * such as a Shadow Root, it'll compare its `innerHTML`.
                                * Otherwise it'll compare two strings representing HTML.
                                */
                            toEqualHtml(expectHtml: string): void;
                            /**
                                * Compares HTML light DOKM only, but first normalizes the HTML so all
                                * whitespace, attribute order and css class order are
                                * the same. When given an element, it will compare
                                * the element's `outerHTML`. When given a Document Fragment,
                                * such as a Shadow Root, it'll compare its `innerHTML`.
                                * Otherwise it'll compare two strings representing HTML.
                                */
                            toEqualLightHtml(expectLightHtml: string): void;
                            /**
                                * When given an element, it'll compare the element's
                                * `textContent`. Otherwise it'll compare two strings. This
                                * matcher will also `trim()` each string before comparing.
                                */
                            toEqualText(expectTextContent: string): void;
                            /**
                                * Checks if an element simply has the attribute. It does
                                * not check any values of the attribute
                                */
                            toHaveAttribute(expectAttrName: string): void;
                            /**
                                * Checks if an element's attribute value equals the expect value.
                                */
                            toEqualAttribute(expectAttrName: string, expectAttrValue: any): void;
                            /**
                                * Checks if an element's has each of the expected attribute
                                * names and values.
                                */
                            toEqualAttributes(expectAttrs: {
                                    [attrName: string]: any;
                            }): void;
                            /**
                                * Checks if an element has the expected css class.
                                */
                            toHaveClass(expectClassName: string): void;
                            /**
                                * Checks if an element has each of the expected css classes
                                * in the array.
                                */
                            toHaveClasses(expectClassNames: string[]): void;
                            /**
                                * Checks if an element has the exact same css classes
                                * as the expected array of css classes.
                                */
                            toMatchClasses(expectClassNames: string[]): void;
                            /**
                                * When given an EventSpy, checks if the event has been
                                * received or not.
                                */
                            toHaveReceivedEvent(): void;
                            /**
                                * When given an EventSpy, checks how many times the
                                * event has been received.
                                */
                            toHaveReceivedEventTimes(count: number): void;
                            /**
                                * When given an EventSpy, checks the event has
                                * received the correct custom event `detail` data.
                                */
                            toHaveReceivedEventDetail(eventDetail: any): void;
                            /**
                                * When given an EventSpy, checks the first event has
                                * received the correct custom event `detail` data.
                                */
                            toHaveFirstReceivedEventDetail(eventDetail: any): void;
                            /**
                                * When given an EventSpy, checks the event at an index
                                * has received the correct custom event `detail` data.
                                */
                            toHaveNthReceivedEventDetail(index: number, eventDetail: any): void;
                            /**
                                * Used to evaluate the results of `compareScreenshot()`, such as
                                * `expect(compare).toMatchScreenshot()`. The `allowableMismatchedRatio`
                                * value from the testing config is used by default if
                                * `MatchScreenshotOptions` were not provided.
                                */
                            toMatchScreenshot(opts?: MatchScreenshotOptions): void;
                    }
            }
    }
    export interface MatchScreenshotOptions {
            /**
                * The `allowableMismatchedPixels` value is the total number of pixels
                * that can be mismatched until the test fails. For example, if the value
                * is `100`, and if there were `101` pixels that were mismatched then the
                * test would fail. If the `allowableMismatchedRatio` is provided it will
                * take precedence, otherwise `allowableMismatchedPixels` will be used.
                */
            allowableMismatchedPixels?: number;
            /**
                * The `allowableMismatchedRatio` ranges from `0` to `1` and is used to
                * determine an acceptable ratio of pixels that can be mismatched before
                * the image is considered to have changes. Realistically, two screenshots
                * representing the same content may have a small number of pixels that
                * are not identical due to anti-aliasing, which is perfectly normal. The
                * `allowableMismatchedRatio` is the number of pixels that were mismatched,
                * divided by the total number of pixels in the screenshot. For example,
                * a ratio value of `0.06` means 6% of the pixels can be mismatched before
                * the image is considered to have changes. If the `allowableMismatchedRatio`
                * is provided it will take precedence, otherwise `allowableMismatchedPixels`
                * will be used.
                */
            allowableMismatchedRatio?: number;
    }
    export interface EventSpy {
            events: SerializedEvent[];
            eventName: string;
            firstEvent: SerializedEvent;
            lastEvent: SerializedEvent;
            length: number;
            next(): Promise<{
                    done: boolean;
                    value: SerializedEvent;
            }>;
    }
    export interface SerializedEvent {
            bubbles: boolean;
            cancelBubble: boolean;
            cancelable: boolean;
            composed: boolean;
            currentTarget: any;
            defaultPrevented: boolean;
            detail: any;
            eventPhase: any;
            isTrusted: boolean;
            returnValue: any;
            srcElement: any;
            target: any;
            timeStamp: number;
            type: string;
            isSerializedEvent: boolean;
    }
    export interface EventInitDict {
            bubbles?: boolean;
            cancelable?: boolean;
            composed?: boolean;
            detail?: any;
    }
    export interface JestEnvironmentGlobal {
            __NEW_TEST_PAGE__: () => Promise<any>;
            __CLOSE_OPEN_PAGES__: () => Promise<any>;
            Context: any;
            loadTestWindow: (testWindow: any) => Promise<void>;
            h: any;
            resourcesUrl: string;
            currentSpec?: {
                    id: string;
                    description: string;
                    fullName: string;
                    testPath: string;
            };
            env: {
                    [prop: string]: string;
            };
            screenshotDescriptions: Set<string>;
    }
    export interface E2EProcessEnv {
            STENCIL_COMMIT_ID?: string;
            STENCIL_COMMIT_MESSAGE?: string;
            STENCIL_REPO_URL?: string;
            STENCIL_SCREENSHOT_CONNECTOR?: string;
            STENCIL_SCREENSHOT_SERVER?: string;
            __STENCIL_EMULATE_CONFIGS__?: string;
            __STENCIL_ENV__?: string;
            __STENCIL_EMULATE__?: string;
            __STENCIL_BROWSER_URL__?: string;
            __STENCIL_APP_SCRIPT_URL__?: string;
            __STENCIL_APP_STYLE_URL__?: string;
            __STENCIL_BROWSER_WS_ENDPOINT__?: string;
            __STENCIL_BROWSER_WAIT_UNTIL?: string;
            __STENCIL_SCREENSHOT__?: 'true';
            __STENCIL_SCREENSHOT_BUILD__?: string;
            __STENCIL_E2E_TESTS__?: 'true';
            __STENCIL_E2E_DEVTOOLS__?: 'true';
            __STENCIL_SPEC_TESTS__?: 'true';
            __STENCIL_PUPPETEER_MODULE__?: string;
            __STENCIL_DEFAULT_TIMEOUT__?: string;
    }
    export interface AnyHTMLElement extends HTMLElement {
            [key: string]: any;
    }
    export interface SpecPage {
            /**
                * Mocked testing `document.body`.
                */
            body: HTMLBodyElement;
            /**
                * Mocked testing `document`.
                */
            doc: HTMLDocument;
            /**
                * The first component found within the mocked `document.body`. If a component isn't found, then it'll return `document.body.firstElementChild`.
                */
            root?: AnyHTMLElement;
            /**
                * Similar to `root`, except returns the component instance. If a root component was not found it'll return `null`.
                */
            rootInstance?: any;
            /**
                * Convenience function to set `document.body.innerHTML` and `waitForChanges()`. Function argument should be an html string.
                */
            setContent: (html: string) => Promise<any>;
            /**
                * After changes have been made to a component, such as a update to a property or attribute, the test page does not automatically apply the changes. In order to wait for, and apply the update, call `await page.waitForChanges()`.
                */
            waitForChanges: () => Promise<any>;
            /**
                * Mocked testing `window`.
                */
            win: Window;
            build: BuildConditionals;
            flushLoadModule: (bundleId?: string) => Promise<any>;
            flushQueue: () => Promise<any>;
            styles: Map<string, string>;
    }
    export interface NewSpecPageOptions {
            /**
                * An array of components to test. Component classes can be imported into the spec file, then their reference should be added to the `component` array in order to be used throughout the test.
                */
            components: any[];
            /**
                * Sets the mocked `document.cookie`.
                */
            cookie?: string;
            /**
                * Sets the mocked `dir` attribute on `<html>`.
                */
            direction?: string;
            flushQueue?: boolean;
            /**
                * The initial HTML used to generate the test. This can be useful to construct a collection of components working together, and assign HTML attributes. This value sets the mocked `document.body.innerHTML`.
                */
            html?: string;
            /**
                * The initial JSX used to generate the test.
                * Use `template` when you want to initialize a component using their properties, instead of their HTML attributes.
                * It will render the specified template (JSX) into `document.body`.
                */
            template?: () => any;
            /**
                * Sets the mocked `lang` attribute on `<html>`.
                */
            language?: string;
            /**
                * Useful for debugging hydrating components client-side. Sets that the `html` option already includes annotated prerender attributes and comments.
                */
            hydrateClientSide?: boolean;
            /**
                * Useful for debugging hydrating components server-side. The output HTML will also include prerender annotations.
                */
            hydrateServerSide?: boolean;
            /**
                * Sets the mocked `document.referrer`.
                */
            referrer?: string;
            /**
                * Manually set if the mocked document supports Shadow DOM or not. Default is `true`.
                */
            supportsShadowDom?: boolean;
            /**
                * When a component is prerendered it includes HTML annotations, such as `s-id` attributes and `<!-t.0->` comments. This information is used by clientside hydrating. Default is `false`.
                */
            includeAnnotations?: boolean;
            /**
                * Sets the mocked browser's `location.href`.
                */
            url?: string;
            /**
                * Sets the mocked browser's `navigator.userAgent`.
                */
            userAgent?: string;
            /**
                * By default, any changes to component properties and attributes must `page.waitForChanges()` in order to test the updates. As an option, `autoAppluChanges` continuously flushes the queue on the background. Default is `false`.
                */
            autoApplyChanges?: boolean;
            /**
                * By default, styles are not attached to the DOM and they are not reflected in the serialized HTML.
                * Setting this option to `true` will include the component's styles in the serializable output.
                */
            attachStyles?: boolean;
            strictBuild?: boolean;
    }
    export interface TypesImportData {
            [key: string]: TypesMemberNameData[];
    }
    export interface TypesMemberNameData {
            localName: string;
            importName?: string;
    }
    export interface TypesModule {
            isDep: boolean;
            tagName: string;
            tagNameAsPascal: string;
            htmlElementName: string;
            component: string;
            jsx: string;
            element: string;
    }
    export type TypeInfo = {
            name: string;
            type: string;
            optional: boolean;
            required: boolean;
            internal: boolean;
            jsdoc?: string;
    }[];
    export interface Hyperscript {
            (sel: any): VNode;
            (sel: Node, data: VNodeData): VNode;
            (sel: any, data: VNodeData): VNode;
            (sel: any, text: string): VNode;
            (sel: any, children: Array<VNode | undefined | null>): VNode;
            (sel: any, data: VNodeData, text: string): VNode;
            (sel: any, data: VNodeData, children: Array<VNode | undefined | null>): VNode;
            (sel: any, data: VNodeData, children: VNode): VNode;
    }
    export type ChildType = VNode | number | string;
    export type PropsType = VNodeProdData | number | string | null;
    export interface VNodeProdData {
            key?: string | number;
            class?: {
                    [className: string]: boolean;
            } | string;
            className?: {
                    [className: string]: boolean;
            } | string;
            style?: any;
            [key: string]: any;
    }
    export interface CompilerWorkerContext {
            optimizeCss(inputOpts: OptimizeCssInput): Promise<OptimizeCssOutput>;
            prepareModule(input: string, minifyOpts: any, transpile: boolean, inlineHelpers: boolean): Promise<{
                    output: string;
                    diagnostics: Diagnostic[];
            }>;
            prerenderWorker(prerenderRequest: PrerenderUrlRequest): Promise<PrerenderUrlResults>;
            transformCssToEsm(input: TransformCssToEsmInput): Promise<TransformCssToEsmOutput>;
    }
    export interface MsgToWorker {
            stencilId: number;
            args: any[];
    }
    export interface MsgFromWorker {
            stencilId?: number;
            stencilRtnValue: any;
            stencilRtnError: string;
    }
    export interface CompilerWorkerTask {
            stencilId?: number;
            inputArgs?: any[];
            resolve: (val: any) => any;
            reject: (msg: string) => any;
            retries?: number;
    }
    export type WorkerMsgHandler = (msgToWorker: MsgToWorker) => Promise<any>;
    export interface WorkerTask {
            taskId: number;
            method: string;
            args: any[];
            resolve: (val: any) => any;
            reject: (msg: string) => any;
            retries: number;
            isLongRunningTask: boolean;
            workerKey: string;
    }
    export interface WorkerMessage {
            taskId?: number;
            method?: string;
            args?: any[];
            value?: any;
            error?: string;
            exit?: boolean;
    }
    export type WorkerRunner = (methodName: string, args: any[]) => Promise<any>;
    export interface WorkerRunnerOptions {
            isLongRunningTask?: boolean;
            workerKey?: string;
    }
    export interface WorkerContext {
            tsHost?: any;
            tsProgram?: any;
    }
    export interface TranspileModuleResults {
            sourceFilePath: string;
            code: string;
            map: any;
            diagnostics: Diagnostic[];
            moduleFile: Module;
    }
    export interface ValidateTypesResults {
            diagnostics: Diagnostic[];
            dirPaths: string[];
            filePaths: string[];
    }
}

declare module '@stencil/core/stencil-public-runtime' {
    type CustomMethodDecorator<T> = (target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | void;
    export interface ComponentDecorator {
            (opts?: ComponentOptions): ClassDecorator;
    }
    export interface ComponentOptions {
            /**
                * Tag name of the web component. Ideally, the tag name must be globally unique,
                * so it's recommended to choose an unique prefix for all your components within the same collection.
                *
                * In addition, tag name must contain a '-'
                */
            tag: string;
            /**
                * If `true`, the component will use scoped stylesheets. Similar to shadow-dom,
                * but without native isolation. Defaults to `false`.
                */
            scoped?: boolean;
            /**
                * If `true`, the component will use native shadow-dom encapsulation, it will fallback to
                * `scoped` if the browser does not support shadow-dom natively. Defaults to `false`.
                * Additionally, `shadow` can also be given options when attaching the shadow root.
                */
            shadow?: boolean | ShadowRootOptions;
            /**
                * Relative URL to some external stylesheet file. It should be a `.css` file unless some
                * external plugin is installed like `@stencil/sass`.
                */
            styleUrl?: string;
            /**
                * Similar as `styleUrl` but allows to specify different stylesheets for different modes.
                */
            styleUrls?: string[] | ModeStyles;
            /**
                * String that contains inlined CSS instead of using an external stylesheet.
                * The performance characteristics of this feature are the same as using an external stylesheet.
                *
                * Notice, you can't use sass, or less, only `css` is allowed using `styles`, use `styleUrl` is you need more advanced features.
                */
            styles?: string | {
                    [modeName: string]: any;
            };
            /**
                * Array of relative links to folders of assets required by the component.
                */
            assetsDirs?: string[];
    }
    export interface ShadowRootOptions {
            /**
                * When set to `true`, specifies behavior that mitigates custom element issues
                * around focusability. When a non-focusable part of the shadow DOM is clicked, the first
                * focusable part is given focus, and the shadow host is given any available `:focus` styling.
                */
            delegatesFocus?: boolean;
    }
    export interface ModeStyles {
            [modeName: string]: string | string[];
    }
    export interface PropDecorator {
            (opts?: PropOptions): PropertyDecorator;
    }
    export interface PropOptions {
            /**
                * The name of the associated DOM attribute.
                * Stencil uses different heuristics to determine the default name of the attribute,
                * but using this property, you can override the default behaviour.
                */
            attribute?: string | null;
            /**
                * A Prop is _by default_ immutable from inside the component logic.
                * Once a value is set by a user, the component cannot update it internally.
                * However, it's possible to explicitly allow a Prop to be mutated from inside the component,
                * by setting this `mutable` option to `true`.
                */
            mutable?: boolean;
            /**
                * In some cases it may be useful to keep a Prop in sync with an attribute.
                * In this case you can set the `reflect` option to `true`, since it defaults to `false`:
                */
            reflect?: boolean;
    }
    export interface MethodDecorator {
            (opts?: MethodOptions): CustomMethodDecorator<any>;
    }
    export interface MethodOptions {
    }
    export interface ElementDecorator {
            (): PropertyDecorator;
    }
    export interface EventDecorator {
            (opts?: EventOptions): PropertyDecorator;
    }
    export interface EventOptions {
            /**
                * A string custom event name to override the default.
                */
            eventName?: string;
            /**
                * A Boolean indicating whether the event bubbles up through the DOM or not.
                */
            bubbles?: boolean;
            /**
                * A Boolean indicating whether the event is cancelable.
                */
            cancelable?: boolean;
            /**
                * A Boolean value indicating whether or not the event can bubble across the boundary between the shadow DOM and the regular DOM.
                */
            composed?: boolean;
    }
    export interface ListenDecorator {
            (eventName: string, opts?: ListenOptions): CustomMethodDecorator<any>;
    }
    export interface ListenOptions {
            /**
                * Handlers can also be registered for an event other than the host itself.
                * The `target` option can be used to change where the event listener is attached,
                * this is useful for listening to application-wide events.
                */
            target?: ListenTargetOptions;
            /**
                * Event listener attached with `@Listen` does not "capture" by default,
                * When a event listener is set to "capture", means the event will be dispatched
                * during the "capture phase". Please see
                * https://www.quirksmode.org/js/events_order.html for further information.
                */
            capture?: boolean;
            /**
                * By default, Stencil uses several heuristics to determine if
                * it must attach a `passive` event listener or not.
                *
                * Using the `passive` option can be used to change the default behaviour.
                * Please see https://developers.google.com/web/updates/2016/06/passive-event-listeners for further information.
                */
            passive?: boolean;
    }
    export type ListenTargetOptions = 'body' | 'document' | 'window';
    export interface StateDecorator {
            (): PropertyDecorator;
    }
    export interface WatchDecorator {
            (propName: string): CustomMethodDecorator<any>;
    }
    export interface UserBuildConditionals {
            isDev: boolean;
            isBrowser: boolean;
            isServer: boolean;
            isTesting: boolean;
    }
    /**
        * The `Build` object provides many build conditionals that can be used to
        * include or exclude code depending on the build.
        */
    export const Build: UserBuildConditionals;
    /**
        * The `Env` object provides access to the "env" object declared in the project's `stencil.config.ts`.
        */
    export const Env: {
            [prop: string]: string | undefined;
    };
    /**
        * The `@Component()` decorator is used to provide metadata about the component class.
        * https://stenciljs.com/docs/component
        */
    export const Component: ComponentDecorator;
    /**
        * The `@Element()` decorator is a reference to the actual host element
        * once it has rendered.
        */
    export const Element: ElementDecorator;
    /**
        * Components can emit data and events using the Event Emitter decorator.
        * To dispatch Custom DOM events for other components to handle, use the
        * `@Event()` decorator. The Event decorator also makes it easier for Stencil
        * to automatically build types and documentation for the event data.
        * https://stenciljs.com/docs/events
        */
    export const Event: EventDecorator;
    /**
        * The `Listen()` decorator is for listening DOM events, including the ones
        * dispatched from `@Events()`.
        * https://stenciljs.com/docs/events#listen-decorator
        */
    export const Listen: ListenDecorator;
    /**
        * The `@Method()` decorator is used to expose methods on the public API.
        * Class methods decorated with the @Method() decorator can be called directly
        * from the element, meaning they are intended to be callable from the outside.
        * https://stenciljs.com/docs/methods
        */
    export const Method: MethodDecorator;
    /**
        * Props are custom attribute/properties exposed publicly on the element
        * that developers can provide values for. Children components do not need to
        * know about or reference parent components, so Props can be used to pass
        * data down from the parent to the child. Components need to explicitly
        * declare the Props they expect to receive using the `@Prop()` decorator.
        * Any value changes to a Prop will cause a re-render.
        * https://stenciljs.com/docs/properties
        */
    export const Prop: PropDecorator;
    /**
        * The `@State()` decorator can be used to manage internal data for a component.
        * This means that a user cannot modify this data from outside the component,
        * but the component can modify it however it sees fit. Any value changes to a
        * `@State()` property will cause the components render function to be called again.
        * https://stenciljs.com/docs/state
        */
    export const State: StateDecorator;
    /**
        * When a property's value has changed, a method decorated with `@Watch()` will be
        * called and passed the new value of the prop along with the old value. Watch is
        * useful for validating props or handling side effects. Watch decorator does not
        * fire when a component initially loads.
        * https://stenciljs.com/docs/reactive-data#watch-decorator
        */
    export const Watch: WatchDecorator;
    export type ResolutionHandler = (elm: HTMLElement) => string | undefined | null;
    export type ErrorHandler = (err: any, element?: HTMLElement) => void;
    /**
        * `setMode()` is used for libraries which provide multiple "modes" for styles.
        */
    export const setMode: (handler: ResolutionHandler) => void;
    /**
        * getMode
        */
    export function getMode<T = string | undefined>(ref: any): T;
    /**
        * Get the base path to where the assets can be found. Use `setAssetPath(path)`
        * if the path needs to be customized.
        */
    export function getAssetPath(path: string): string;
    /**
        * Used to manually set the base path where assets can be found. For lazy-loaded
        * builds the asset path is automatically set and assets copied to the correct
        * build directory. However, for custom elements builds, the `setAssetPath(path)` could
        * be used to customize the asset path depending on how the script file is consumed.
        * If the script is used as "module", it's recommended to use "import.meta.url", such
        * as `setAssetPath(import.meta.url)`. Other options include
        * `setAssetPath(document.currentScript.src)`, or using a bundler's replace plugin to
        * dynamically set the path at build time, such as `setAssetPath(process.env.ASSET_PATH)`.
        * But do note that this configuration depends on how your script is bundled, or lack of
        * bunding, and where your assets can be loaded from. Additionally custom bundling
        * will have to ensure the static assets are copied to its build directory.
        */
    export function setAssetPath(path: string): string;
    /**
        * getElement
        */
    export function getElement(ref: any): HTMLStencilElement;
    /**
        * Schedules a new render of the given instance or element even if no state changed.
        *
        * Notice `forceUpdate()` is not syncronous and might perform the DOM render in the next frame.
        */
    export function forceUpdate(ref: any): void;
    /**
        * getRenderingRef
        */
    export function getRenderingRef(): any;
    export interface HTMLStencilElement extends HTMLElement {
            componentOnReady(): Promise<this>;
    }
    /**
        * Schedules a DOM-write task. The provided callback will be executed
        * in the best moment to perform DOM mutation without causing layout thrashing.
        *
        * For further information: https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing
        */
    export function writeTask(task: RafCallback): void;
    /**
        * Schedules a DOM-read task. The provided callback will be executed
        * in the best moment to perform DOM reads without causing layout thrashing.
        *
        * For further information: https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing
        */
    export function readTask(task: RafCallback): void;
    /**
        * `setErrorHandler()` can be used to inject a custom global error handler.
        * Unhandled exception raised while rendering, during event handling, or lifecycles will trigger the custom event handler.
        */
    export const setErrorHandler: (handler: ErrorHandler) => void;
    /**
        * This file gets copied to all distributions of stencil component collections.
        * - no imports
        */
    export interface ComponentWillLoad {
            /**
                * The component is about to load and it has not
                * rendered yet.
                *
                * This is the best place to make any data updates
                * before the first render.
                *
                * componentWillLoad will only be called once.
                */
            componentWillLoad(): Promise<void> | void;
    }
    export interface ComponentDidLoad {
            /**
                * The component has loaded and has already rendered.
                *
                * Updating data in this method will cause the
                * component to re-render.
                *
                * componentDidLoad will only be called once.
                */
            componentDidLoad(): void;
    }
    export interface ComponentWillUpdate {
            /**
                * The component is about to update and re-render.
                *
                * Called multiple times throughout the life of
                * the component as it updates.
                *
                * componentWillUpdate is not called on the first render.
                */
            componentWillUpdate(): Promise<void> | void;
    }
    export interface ComponentDidUpdate {
            /**
                * The component has just re-rendered.
                *
                * Called multiple times throughout the life of
                * the component as it updates.
                *
                * componentWillUpdate is not called on the
                * first render.
                */
            componentDidUpdate(): void;
    }
    export interface ComponentInterface {
            connectedCallback?(): void;
            disconnectedCallback?(): void;
            componentWillRender?(): Promise<void> | void;
            componentDidRender?(): void;
            /**
                * The component is about to load and it has not
                * rendered yet.
                *
                * This is the best place to make any data updates
                * before the first render.
                *
                * componentWillLoad will only be called once.
                */
            componentWillLoad?(): Promise<void> | void;
            /**
                * The component has loaded and has already rendered.
                *
                * Updating data in this method will cause the
                * component to re-render.
                *
                * componentDidLoad will only be called once.
                */
            componentDidLoad?(): void;
            /**
                * A `@Prop` or `@State` property changed and a rerender is about to be requested.
                *
                * Called multiple times throughout the life of
                * the component as its properties change.
                *
                * componentShouldUpdate is not called on the first render.
                */
            componentShouldUpdate?(newVal: any, oldVal: any, propName: string): boolean | void;
            /**
                * The component is about to update and re-render.
                *
                * Called multiple times throughout the life of
                * the component as it updates.
                *
                * componentWillUpdate is not called on the first render.
                */
            componentWillUpdate?(): Promise<void> | void;
            /**
                * The component has just re-rendered.
                *
                * Called multiple times throughout the life of
                * the component as it updates.
                *
                * componentWillUpdate is not called on the
                * first render.
                */
            componentDidUpdate?(): void;
            render?(): any;
            [memberName: string]: any;
    }
    export interface EventEmitter<T = any> {
            emit: (data?: T) => CustomEvent<T>;
    }
    export interface RafCallback {
            (timeStamp: number): void;
    }
    export interface QueueApi {
            tick: (cb: RafCallback) => void;
            read: (cb: RafCallback) => void;
            write: (cb: RafCallback) => void;
            clear?: () => void;
            flush?: (cb?: () => void) => void;
    }
    /**
        * Host
        */
    interface HostAttributes {
            class?: string | {
                    [className: string]: boolean;
            };
            style?: {
                    [key: string]: string | undefined;
            };
            ref?: (el: HTMLElement | null) => void;
            [prop: string]: any;
    }
    export interface FunctionalUtilities {
            forEach: (children: VNode[], cb: (vnode: ChildNode, index: number, array: ChildNode[]) => void) => void;
            map: (children: VNode[], cb: (vnode: ChildNode, index: number, array: ChildNode[]) => ChildNode) => VNode[];
    }
    export interface FunctionalComponent<T = {}> {
            (props: T, children: VNode[], utils: FunctionalUtilities): VNode | VNode[];
    }
    export interface ChildNode {
            vtag?: string | number | Function;
            vkey?: string | number;
            vtext?: string;
            vchildren?: VNode[];
            vattrs?: any;
            vname?: string;
    }
    /**
        * Host is a functional component can be used at the root of the render function
        * to set attributes and event listeners to the host element itself.
        *
        * For further information: https://stenciljs.com/docs/host-element
        */
    export const Host: FunctionalComponent<HostAttributes>;
    /**
        * Fragment
        */
    export const Fragment: FunctionalComponent<{}>;
    /**
        * The "h" namespace is used to import JSX types for elements and attributes.
        * It is imported in order to avoid conflicting global JSX issues.
        */
    export namespace h {
            function h(sel: any): VNode;
            function h(sel: Node, data: VNodeData | null): VNode;
            function h(sel: any, data: VNodeData | null): VNode;
            function h(sel: any, text: string): VNode;
            function h(sel: any, children: Array<VNode | undefined | null>): VNode;
            function h(sel: any, data: VNodeData | null, text: string): VNode;
            function h(sel: any, data: VNodeData | null, children: Array<VNode | undefined | null>): VNode;
            function h(sel: any, data: VNodeData | null, children: VNode): VNode;
            namespace JSX {
                    interface IntrinsicElements extends LocalJSX.IntrinsicElements, JSXBase.IntrinsicElements {
                            [tagName: string]: any;
                    }
            }
    }
    export function h(sel: any): VNode;
    export function h(sel: Node, data: VNodeData | null): VNode;
    export function h(sel: any, data: VNodeData | null): VNode;
    export function h(sel: any, text: string): VNode;
    export function h(sel: any, children: Array<VNode | undefined | null>): VNode;
    export function h(sel: any, data: VNodeData | null, text: string): VNode;
    export function h(sel: any, data: VNodeData | null, children: Array<VNode | undefined | null>): VNode;
    export function h(sel: any, data: VNodeData | null, children: VNode): VNode;
    export interface VNode {
            $flags$: number;
            $tag$: string | number | Function;
            $elm$: any;
            $text$: string;
            $children$: VNode[];
            $attrs$?: any;
            $name$?: string;
            $key$?: string | number;
    }
    export interface VNodeData {
            class?: {
                    [className: string]: boolean;
            };
            style?: any;
            [attrName: string]: any;
    }
    namespace LocalJSX {
            interface Element {
            }
            interface IntrinsicElements {
            }
    }
    export { LocalJSX as JSX };
    export namespace JSXBase {
            interface IntrinsicElements {
                    slot: JSXBase.SlotAttributes;
                    a: JSXBase.AnchorHTMLAttributes<HTMLAnchorElement>;
                    abbr: JSXBase.HTMLAttributes;
                    address: JSXBase.HTMLAttributes;
                    area: JSXBase.AreaHTMLAttributes<HTMLAreaElement>;
                    article: JSXBase.HTMLAttributes;
                    aside: JSXBase.HTMLAttributes;
                    audio: JSXBase.AudioHTMLAttributes<HTMLAudioElement>;
                    b: JSXBase.HTMLAttributes;
                    base: JSXBase.BaseHTMLAttributes<HTMLBaseElement>;
                    bdi: JSXBase.HTMLAttributes;
                    bdo: JSXBase.HTMLAttributes;
                    big: JSXBase.HTMLAttributes;
                    blockquote: JSXBase.BlockquoteHTMLAttributes<HTMLQuoteElement>;
                    body: JSXBase.HTMLAttributes<HTMLBodyElement>;
                    br: JSXBase.HTMLAttributes<HTMLBRElement>;
                    button: JSXBase.ButtonHTMLAttributes<HTMLButtonElement>;
                    canvas: JSXBase.CanvasHTMLAttributes<HTMLCanvasElement>;
                    caption: JSXBase.HTMLAttributes<HTMLTableCaptionElement>;
                    cite: JSXBase.HTMLAttributes;
                    code: JSXBase.HTMLAttributes;
                    col: JSXBase.ColHTMLAttributes<HTMLTableColElement>;
                    colgroup: JSXBase.ColgroupHTMLAttributes<HTMLTableColElement>;
                    data: JSXBase.HTMLAttributes<HTMLDataElement>;
                    datalist: JSXBase.HTMLAttributes<HTMLDataListElement>;
                    dd: JSXBase.HTMLAttributes;
                    del: JSXBase.DelHTMLAttributes<HTMLModElement>;
                    details: JSXBase.DetailsHTMLAttributes<HTMLElement>;
                    dfn: JSXBase.HTMLAttributes;
                    dialog: JSXBase.DialogHTMLAttributes<HTMLDialogElement>;
                    div: JSXBase.HTMLAttributes<HTMLDivElement>;
                    dl: JSXBase.HTMLAttributes<HTMLDListElement>;
                    dt: JSXBase.HTMLAttributes;
                    em: JSXBase.HTMLAttributes;
                    embed: JSXBase.EmbedHTMLAttributes<HTMLEmbedElement>;
                    fieldset: JSXBase.FieldsetHTMLAttributes<HTMLFieldSetElement>;
                    figcaption: JSXBase.HTMLAttributes;
                    figure: JSXBase.HTMLAttributes;
                    footer: JSXBase.HTMLAttributes;
                    form: JSXBase.FormHTMLAttributes<HTMLFormElement>;
                    h1: JSXBase.HTMLAttributes<HTMLHeadingElement>;
                    h2: JSXBase.HTMLAttributes<HTMLHeadingElement>;
                    h3: JSXBase.HTMLAttributes<HTMLHeadingElement>;
                    h4: JSXBase.HTMLAttributes<HTMLHeadingElement>;
                    h5: JSXBase.HTMLAttributes<HTMLHeadingElement>;
                    h6: JSXBase.HTMLAttributes<HTMLHeadingElement>;
                    head: JSXBase.HTMLAttributes<HTMLHeadElement>;
                    header: JSXBase.HTMLAttributes;
                    hgroup: JSXBase.HTMLAttributes;
                    hr: JSXBase.HTMLAttributes<HTMLHRElement>;
                    html: JSXBase.HTMLAttributes<HTMLHtmlElement>;
                    i: JSXBase.HTMLAttributes;
                    iframe: JSXBase.IframeHTMLAttributes<HTMLIFrameElement>;
                    img: JSXBase.ImgHTMLAttributes<HTMLImageElement>;
                    input: JSXBase.InputHTMLAttributes<HTMLInputElement>;
                    ins: JSXBase.InsHTMLAttributes<HTMLModElement>;
                    kbd: JSXBase.HTMLAttributes;
                    keygen: JSXBase.KeygenHTMLAttributes<HTMLElement>;
                    label: JSXBase.LabelHTMLAttributes<HTMLLabelElement>;
                    legend: JSXBase.HTMLAttributes<HTMLLegendElement>;
                    li: JSXBase.LiHTMLAttributes<HTMLLIElement>;
                    link: JSXBase.LinkHTMLAttributes<HTMLLinkElement>;
                    main: JSXBase.HTMLAttributes;
                    map: JSXBase.MapHTMLAttributes<HTMLMapElement>;
                    mark: JSXBase.HTMLAttributes;
                    menu: JSXBase.MenuHTMLAttributes<HTMLMenuElement>;
                    menuitem: JSXBase.HTMLAttributes;
                    meta: JSXBase.MetaHTMLAttributes<HTMLMetaElement>;
                    meter: JSXBase.MeterHTMLAttributes<HTMLMeterElement>;
                    nav: JSXBase.HTMLAttributes;
                    noscript: JSXBase.HTMLAttributes;
                    object: JSXBase.ObjectHTMLAttributes<HTMLObjectElement>;
                    ol: JSXBase.OlHTMLAttributes<HTMLOListElement>;
                    optgroup: JSXBase.OptgroupHTMLAttributes<HTMLOptGroupElement>;
                    option: JSXBase.OptionHTMLAttributes<HTMLOptionElement>;
                    output: JSXBase.OutputHTMLAttributes<HTMLOutputElement>;
                    p: JSXBase.HTMLAttributes<HTMLParagraphElement>;
                    param: JSXBase.ParamHTMLAttributes<HTMLParamElement>;
                    picture: JSXBase.HTMLAttributes<HTMLPictureElement>;
                    pre: JSXBase.HTMLAttributes<HTMLPreElement>;
                    progress: JSXBase.ProgressHTMLAttributes<HTMLProgressElement>;
                    q: JSXBase.QuoteHTMLAttributes<HTMLQuoteElement>;
                    rp: JSXBase.HTMLAttributes;
                    rt: JSXBase.HTMLAttributes;
                    ruby: JSXBase.HTMLAttributes;
                    s: JSXBase.HTMLAttributes;
                    samp: JSXBase.HTMLAttributes;
                    script: JSXBase.ScriptHTMLAttributes<HTMLScriptElement>;
                    section: JSXBase.HTMLAttributes;
                    select: JSXBase.SelectHTMLAttributes<HTMLSelectElement>;
                    small: JSXBase.HTMLAttributes;
                    source: JSXBase.SourceHTMLAttributes<HTMLSourceElement>;
                    span: JSXBase.HTMLAttributes<HTMLSpanElement>;
                    strong: JSXBase.HTMLAttributes;
                    style: JSXBase.StyleHTMLAttributes<HTMLStyleElement>;
                    sub: JSXBase.HTMLAttributes;
                    summary: JSXBase.HTMLAttributes;
                    sup: JSXBase.HTMLAttributes;
                    table: JSXBase.TableHTMLAttributes<HTMLTableElement>;
                    tbody: JSXBase.HTMLAttributes<HTMLTableSectionElement>;
                    td: JSXBase.TdHTMLAttributes<HTMLTableDataCellElement>;
                    textarea: JSXBase.TextareaHTMLAttributes<HTMLTextAreaElement>;
                    tfoot: JSXBase.HTMLAttributes<HTMLTableSectionElement>;
                    th: JSXBase.ThHTMLAttributes<HTMLTableHeaderCellElement>;
                    thead: JSXBase.HTMLAttributes<HTMLTableSectionElement>;
                    time: JSXBase.TimeHTMLAttributes<HTMLTimeElement>;
                    title: JSXBase.HTMLAttributes<HTMLTitleElement>;
                    tr: JSXBase.HTMLAttributes<HTMLTableRowElement>;
                    track: JSXBase.TrackHTMLAttributes<HTMLTrackElement>;
                    u: JSXBase.HTMLAttributes;
                    ul: JSXBase.HTMLAttributes<HTMLUListElement>;
                    var: JSXBase.HTMLAttributes;
                    video: JSXBase.VideoHTMLAttributes<HTMLVideoElement>;
                    wbr: JSXBase.HTMLAttributes;
                    animate: JSXBase.SVGAttributes;
                    circle: JSXBase.SVGAttributes;
                    clipPath: JSXBase.SVGAttributes;
                    defs: JSXBase.SVGAttributes;
                    desc: JSXBase.SVGAttributes;
                    ellipse: JSXBase.SVGAttributes;
                    feBlend: JSXBase.SVGAttributes;
                    feColorMatrix: JSXBase.SVGAttributes;
                    feComponentTransfer: JSXBase.SVGAttributes;
                    feComposite: JSXBase.SVGAttributes;
                    feConvolveMatrix: JSXBase.SVGAttributes;
                    feDiffuseLighting: JSXBase.SVGAttributes;
                    feDisplacementMap: JSXBase.SVGAttributes;
                    feDistantLight: JSXBase.SVGAttributes;
                    feDropShadow: JSXBase.SVGAttributes;
                    feFlood: JSXBase.SVGAttributes;
                    feFuncA: JSXBase.SVGAttributes;
                    feFuncB: JSXBase.SVGAttributes;
                    feFuncG: JSXBase.SVGAttributes;
                    feFuncR: JSXBase.SVGAttributes;
                    feGaussianBlur: JSXBase.SVGAttributes;
                    feImage: JSXBase.SVGAttributes;
                    feMerge: JSXBase.SVGAttributes;
                    feMergeNode: JSXBase.SVGAttributes;
                    feMorphology: JSXBase.SVGAttributes;
                    feOffset: JSXBase.SVGAttributes;
                    fePointLight: JSXBase.SVGAttributes;
                    feSpecularLighting: JSXBase.SVGAttributes;
                    feSpotLight: JSXBase.SVGAttributes;
                    feTile: JSXBase.SVGAttributes;
                    feTurbulence: JSXBase.SVGAttributes;
                    filter: JSXBase.SVGAttributes;
                    foreignObject: JSXBase.SVGAttributes;
                    g: JSXBase.SVGAttributes;
                    image: JSXBase.SVGAttributes;
                    line: JSXBase.SVGAttributes;
                    linearGradient: JSXBase.SVGAttributes;
                    marker: JSXBase.SVGAttributes;
                    mask: JSXBase.SVGAttributes;
                    metadata: JSXBase.SVGAttributes;
                    path: JSXBase.SVGAttributes;
                    pattern: JSXBase.SVGAttributes;
                    polygon: JSXBase.SVGAttributes;
                    polyline: JSXBase.SVGAttributes;
                    radialGradient: JSXBase.SVGAttributes;
                    rect: JSXBase.SVGAttributes;
                    stop: JSXBase.SVGAttributes;
                    svg: JSXBase.SVGAttributes;
                    switch: JSXBase.SVGAttributes;
                    symbol: JSXBase.SVGAttributes;
                    text: JSXBase.SVGAttributes;
                    textPath: JSXBase.SVGAttributes;
                    tspan: JSXBase.SVGAttributes;
                    use: JSXBase.SVGAttributes;
                    view: JSXBase.SVGAttributes;
            }
            interface SlotAttributes {
                    name?: string;
                    slot?: string;
                    onSlotchange?: (event: Event) => void;
            }
            interface AnchorHTMLAttributes<T> extends HTMLAttributes<T> {
                    download?: any;
                    href?: string;
                    hrefLang?: string;
                    hreflang?: string;
                    media?: string;
                    rel?: string;
                    target?: string;
            }
            interface AudioHTMLAttributes<T> extends MediaHTMLAttributes<T> {
            }
            interface AreaHTMLAttributes<T> extends HTMLAttributes<T> {
                    alt?: string;
                    coords?: string;
                    download?: any;
                    href?: string;
                    hrefLang?: string;
                    hreflang?: string;
                    media?: string;
                    rel?: string;
                    shape?: string;
                    target?: string;
            }
            interface BaseHTMLAttributes<T> extends HTMLAttributes<T> {
                    href?: string;
                    target?: string;
            }
            interface BlockquoteHTMLAttributes<T> extends HTMLAttributes<T> {
                    cite?: string;
            }
            interface ButtonHTMLAttributes<T> extends HTMLAttributes<T> {
                    autoFocus?: boolean;
                    disabled?: boolean;
                    form?: string;
                    formAction?: string;
                    formaction?: string;
                    formEncType?: string;
                    formenctype?: string;
                    formMethod?: string;
                    formmethod?: string;
                    formNoValidate?: boolean;
                    formnovalidate?: boolean;
                    formTarget?: string;
                    formtarget?: string;
                    name?: string;
                    type?: string;
                    value?: string | string[] | number;
            }
            interface CanvasHTMLAttributes<T> extends HTMLAttributes<T> {
                    height?: number | string;
                    width?: number | string;
            }
            interface ColHTMLAttributes<T> extends HTMLAttributes<T> {
                    span?: number;
            }
            interface ColgroupHTMLAttributes<T> extends HTMLAttributes<T> {
                    span?: number;
            }
            interface DetailsHTMLAttributes<T> extends HTMLAttributes<T> {
                    open?: boolean;
                    onToggle?: (event: Event) => void;
            }
            interface DelHTMLAttributes<T> extends HTMLAttributes<T> {
                    cite?: string;
                    dateTime?: string;
                    datetime?: string;
            }
            interface DialogHTMLAttributes<T> extends HTMLAttributes<T> {
                    onClose?: (event: Event) => void;
                    open?: boolean;
                    returnValue?: string;
            }
            interface EmbedHTMLAttributes<T> extends HTMLAttributes<T> {
                    height?: number | string;
                    src?: string;
                    type?: string;
                    width?: number | string;
            }
            interface FieldsetHTMLAttributes<T> extends HTMLAttributes<T> {
                    disabled?: boolean;
                    form?: string;
                    name?: string;
            }
            interface FormHTMLAttributes<T> extends HTMLAttributes<T> {
                    acceptCharset?: string;
                    acceptcharset?: string;
                    action?: string;
                    autoComplete?: string;
                    autocomplete?: string;
                    encType?: string;
                    enctype?: string;
                    method?: string;
                    name?: string;
                    noValidate?: boolean;
                    novalidate?: boolean | string;
                    target?: string;
            }
            interface HtmlHTMLAttributes<T> extends HTMLAttributes<T> {
                    manifest?: string;
            }
            interface IframeHTMLAttributes<T> extends HTMLAttributes<T> {
                    allow?: string;
                    allowFullScreen?: boolean;
                    allowfullScreen?: string | boolean;
                    allowTransparency?: boolean;
                    allowtransparency?: string | boolean;
                    frameBorder?: number | string;
                    frameborder?: number | string;
                    importance?: 'low' | 'auto' | 'high';
                    height?: number | string;
                    loading?: 'lazy' | 'auto' | 'eager';
                    marginHeight?: number;
                    marginheight?: string | number;
                    marginWidth?: number;
                    marginwidth?: string | number;
                    name?: string;
                    referrerPolicy?: ReferrerPolicy;
                    sandbox?: string;
                    scrolling?: string;
                    seamless?: boolean;
                    src?: string;
                    srcDoc?: string;
                    srcdoc?: string;
                    width?: number | string;
            }
            interface ImgHTMLAttributes<T> extends HTMLAttributes<T> {
                    alt?: string;
                    decoding?: 'async' | 'auto' | 'sync';
                    importance?: 'low' | 'auto' | 'high';
                    height?: number | string;
                    loading?: 'lazy' | 'auto' | 'eager';
                    sizes?: string;
                    src?: string;
                    srcSet?: string;
                    srcset?: string;
                    useMap?: string;
                    usemap?: string;
                    width?: number | string;
            }
            interface InsHTMLAttributes<T> extends HTMLAttributes<T> {
                    cite?: string;
                    dateTime?: string;
                    datetime?: string;
            }
            interface InputHTMLAttributes<T> extends HTMLAttributes<T> {
                    accept?: string;
                    allowdirs?: boolean;
                    alt?: string;
                    autoCapitalize?: any;
                    autocapitalize?: any;
                    autoComplete?: string;
                    autocomplete?: string;
                    autoFocus?: boolean;
                    autofocus?: boolean | string;
                    capture?: string;
                    checked?: boolean;
                    crossOrigin?: string;
                    crossorigin?: string;
                    defaultChecked?: boolean;
                    defaultValue?: string;
                    dirName?: string;
                    disabled?: boolean;
                    files?: any;
                    form?: string;
                    formAction?: string;
                    formaction?: string;
                    formEncType?: string;
                    formenctype?: string;
                    formMethod?: string;
                    formmethod?: string;
                    formNoValidate?: boolean;
                    formnovalidate?: boolean;
                    formTarget?: string;
                    formtarget?: string;
                    height?: number | string;
                    indeterminate?: boolean;
                    list?: string;
                    max?: number | string;
                    maxLength?: number;
                    maxlength?: number | string;
                    min?: number | string;
                    minLength?: number;
                    minlength?: number | string;
                    multiple?: boolean;
                    name?: string;
                    pattern?: string;
                    placeholder?: string;
                    readOnly?: boolean;
                    readonly?: boolean | string;
                    required?: boolean;
                    selectionStart?: number | string;
                    selectionEnd?: number | string;
                    selectionDirection?: string;
                    size?: number;
                    src?: string;
                    step?: number | string;
                    type?: string;
                    value?: string | string[] | number;
                    valueAsDate?: any;
                    valueAsNumber?: any;
                    webkitdirectory?: boolean;
                    webkitEntries?: any;
                    width?: number | string;
            }
            interface KeygenHTMLAttributes<T> extends HTMLAttributes<T> {
                    autoFocus?: boolean;
                    autofocus?: boolean | string;
                    challenge?: string;
                    disabled?: boolean;
                    form?: string;
                    keyType?: string;
                    keytype?: string;
                    keyParams?: string;
                    keyparams?: string;
                    name?: string;
            }
            interface LabelHTMLAttributes<T> extends HTMLAttributes<T> {
                    form?: string;
                    htmlFor?: string;
                    htmlfor?: string;
            }
            interface LiHTMLAttributes<T> extends HTMLAttributes<T> {
                    value?: string | string[] | number;
            }
            interface LinkHTMLAttributes<T> extends HTMLAttributes<T> {
                    as?: string;
                    href?: string;
                    hrefLang?: string;
                    hreflang?: string;
                    importance?: 'low' | 'auto' | 'high';
                    integrity?: string;
                    media?: string;
                    rel?: string;
                    sizes?: string;
                    type?: string;
            }
            interface MapHTMLAttributes<T> extends HTMLAttributes<T> {
                    name?: string;
            }
            interface MenuHTMLAttributes<T> extends HTMLAttributes<T> {
                    type?: string;
            }
            interface MediaHTMLAttributes<T> extends HTMLAttributes<T> {
                    autoPlay?: boolean;
                    autoplay?: boolean | string;
                    controls?: boolean;
                    crossOrigin?: string;
                    crossorigin?: string;
                    loop?: boolean;
                    mediaGroup?: string;
                    mediagroup?: string;
                    muted?: boolean;
                    preload?: string;
                    src?: string;
                    onAbort?: (event: Event) => void;
                    onCanPlay?: (event: Event) => void;
                    onCanPlayThrough?: (event: Event) => void;
                    onDurationChange?: (event: Event) => void;
                    onEmptied?: (event: Event) => void;
                    onEnded?: (event: Event) => void;
                    onError?: (event: Event) => void;
                    onInterruptBegin?: (event: Event) => void;
                    onInterruptEnd?: (event: Event) => void;
                    onLoadedData?: (event: Event) => void;
                    onLoadedMetaData?: (event: Event) => void;
                    onLoadStart?: (event: Event) => void;
                    onMozAudioAvailable?: (event: Event) => void;
                    onPause?: (event: Event) => void;
                    onPlay?: (event: Event) => void;
                    onPlaying?: (event: Event) => void;
                    onProgress?: (event: Event) => void;
                    onRateChange?: (event: Event) => void;
                    onSeeked?: (event: Event) => void;
                    onSeeking?: (event: Event) => void;
                    onStalled?: (event: Event) => void;
                    onSuspend?: (event: Event) => void;
                    onTimeUpdate?: (event: Event) => void;
                    onVolumeChange?: (event: Event) => void;
                    onWaiting?: (event: Event) => void;
            }
            interface MetaHTMLAttributes<T> extends HTMLAttributes<T> {
                    charSet?: string;
                    charset?: string;
                    content?: string;
                    httpEquiv?: string;
                    httpequiv?: string;
                    name?: string;
            }
            interface MeterHTMLAttributes<T> extends HTMLAttributes<T> {
                    form?: string;
                    high?: number;
                    low?: number;
                    max?: number | string;
                    min?: number | string;
                    optimum?: number;
                    value?: string | string[] | number;
            }
            interface QuoteHTMLAttributes<T> extends HTMLAttributes<T> {
                    cite?: string;
            }
            interface ObjectHTMLAttributes<T> extends HTMLAttributes<T> {
                    classID?: string;
                    classid?: string;
                    data?: string;
                    form?: string;
                    height?: number | string;
                    name?: string;
                    type?: string;
                    useMap?: string;
                    usemap?: string;
                    width?: number | string;
                    wmode?: string;
            }
            interface OlHTMLAttributes<T> extends HTMLAttributes<T> {
                    reversed?: boolean;
                    start?: number;
            }
            interface OptgroupHTMLAttributes<T> extends HTMLAttributes<T> {
                    disabled?: boolean;
                    label?: string;
            }
            interface OptionHTMLAttributes<T> extends HTMLAttributes<T> {
                    disabled?: boolean;
                    label?: string;
                    selected?: boolean;
                    value?: string | string[] | number;
            }
            interface OutputHTMLAttributes<T> extends HTMLAttributes<T> {
                    form?: string;
                    htmlFor?: string;
                    htmlfor?: string;
                    name?: string;
            }
            interface ParamHTMLAttributes<T> extends HTMLAttributes<T> {
                    name?: string;
                    value?: string | string[] | number;
            }
            interface ProgressHTMLAttributes<T> extends HTMLAttributes<T> {
                    max?: number | string;
                    value?: string | string[] | number;
            }
            interface ScriptHTMLAttributes<T> extends HTMLAttributes<T> {
                    async?: boolean;
                    charSet?: string;
                    charset?: string;
                    crossOrigin?: string;
                    crossorigin?: string;
                    defer?: boolean;
                    importance?: 'low' | 'auto' | 'high';
                    integrity?: string;
                    nonce?: string;
                    src?: string;
                    type?: string;
            }
            interface SelectHTMLAttributes<T> extends HTMLAttributes<T> {
                    autoFocus?: boolean;
                    disabled?: boolean;
                    form?: string;
                    multiple?: boolean;
                    name?: string;
                    required?: boolean;
                    size?: number;
                    autoComplete?: string;
                    autocomplete?: string;
            }
            interface SourceHTMLAttributes<T> extends HTMLAttributes<T> {
                    media?: string;
                    sizes?: string;
                    src?: string;
                    srcSet?: string;
                    type?: string;
            }
            interface StyleHTMLAttributes<T> extends HTMLAttributes<T> {
                    media?: string;
                    nonce?: string;
                    scoped?: boolean;
                    type?: string;
            }
            interface TableHTMLAttributes<T> extends HTMLAttributes<T> {
                    cellPadding?: number | string;
                    cellpadding?: number | string;
                    cellSpacing?: number | string;
                    cellspacing?: number | string;
                    summary?: string;
            }
            interface TextareaHTMLAttributes<T> extends HTMLAttributes<T> {
                    autoFocus?: boolean;
                    autofocus?: boolean | string;
                    cols?: number;
                    disabled?: boolean;
                    form?: string;
                    maxLength?: number;
                    maxlength?: number | string;
                    minLength?: number;
                    minlength?: number | string;
                    name?: string;
                    placeholder?: string;
                    readOnly?: boolean;
                    readonly?: boolean | string;
                    required?: boolean;
                    rows?: number;
                    value?: string | string[] | number;
                    wrap?: string;
            }
            interface TdHTMLAttributes<T> extends HTMLAttributes<T> {
                    colSpan?: number;
                    headers?: string;
                    rowSpan?: number;
            }
            interface ThHTMLAttributes<T> extends HTMLAttributes<T> {
                    abbr?: string;
                    colSpan?: number;
                    headers?: string;
                    rowSpan?: number;
                    rowspan?: number | string;
                    scope?: string;
            }
            interface TimeHTMLAttributes<T> extends HTMLAttributes<T> {
                    dateTime?: string;
            }
            interface TrackHTMLAttributes<T> extends HTMLAttributes<T> {
                    default?: boolean;
                    kind?: string;
                    label?: string;
                    src?: string;
                    srcLang?: string;
                    srclang?: string;
            }
            interface VideoHTMLAttributes<T> extends MediaHTMLAttributes<T> {
                    height?: number | string;
                    playsInline?: boolean;
                    playsinline?: boolean | string;
                    poster?: string;
                    width?: number | string;
            }
            interface HTMLAttributes<T = HTMLElement> extends DOMAttributes<T> {
                    innerHTML?: string;
                    accessKey?: string;
                    class?: string | {
                            [className: string]: boolean;
                    };
                    contentEditable?: boolean | string;
                    contenteditable?: boolean | string;
                    contextMenu?: string;
                    contextmenu?: string;
                    dir?: string;
                    draggable?: boolean;
                    hidden?: boolean;
                    id?: string;
                    lang?: string;
                    spellcheck?: 'true' | 'false' | any;
                    style?: {
                            [key: string]: string | undefined;
                    };
                    tabIndex?: number;
                    tabindex?: number | string;
                    title?: string;
                    inputMode?: string;
                    inputmode?: string;
                    enterKeyHint?: string;
                    enterkeyhint?: string;
                    is?: string;
                    radioGroup?: string;
                    radiogroup?: string;
                    role?: string;
                    about?: string;
                    datatype?: string;
                    inlist?: any;
                    prefix?: string;
                    property?: string;
                    resource?: string;
                    typeof?: string;
                    vocab?: string;
                    autoCapitalize?: any;
                    autocapitalize?: any;
                    autoCorrect?: string;
                    autocorrect?: string;
                    autoSave?: string;
                    autosave?: string;
                    color?: string;
                    itemProp?: string;
                    itemprop?: string;
                    itemScope?: boolean;
                    itemscope?: boolean;
                    itemType?: string;
                    itemtype?: string;
                    itemID?: string;
                    itemid?: string;
                    itemRef?: string;
                    itemref?: string;
                    results?: number;
                    security?: string;
                    unselectable?: boolean;
            }
            interface SVGAttributes<T = SVGElement> extends DOMAttributes<T> {
                    'class'?: string | {
                            [className: string]: boolean;
                    };
                    'color'?: string;
                    'height'?: number | string;
                    'id'?: string;
                    'lang'?: string;
                    'max'?: number | string;
                    'media'?: string;
                    'method'?: string;
                    'min'?: number | string;
                    'name'?: string;
                    'style'?: {
                            [key: string]: string | undefined;
                    };
                    'target'?: string;
                    'type'?: string;
                    'width'?: number | string;
                    'role'?: string;
                    'tabindex'?: number;
                    'accent-height'?: number | string;
                    'accumulate'?: 'none' | 'sum';
                    'additive'?: 'replace' | 'sum';
                    'alignment-baseline'?: 'auto' | 'baseline' | 'before-edge' | 'text-before-edge' | 'middle' | 'central' | 'after-edge' | 'text-after-edge' | 'ideographic' | 'alphabetic' | 'hanging' | 'mathematical' | 'inherit';
                    'allowReorder'?: 'no' | 'yes';
                    'alphabetic'?: number | string;
                    'amplitude'?: number | string;
                    'arabic-form'?: 'initial' | 'medial' | 'terminal' | 'isolated';
                    'ascent'?: number | string;
                    'attributeName'?: string;
                    'attributeType'?: string;
                    'autoReverse'?: number | string;
                    'azimuth'?: number | string;
                    'baseFrequency'?: number | string;
                    'baseline-shift'?: number | string;
                    'baseProfile'?: number | string;
                    'bbox'?: number | string;
                    'begin'?: number | string;
                    'bias'?: number | string;
                    'by'?: number | string;
                    'calcMode'?: number | string;
                    'cap-height'?: number | string;
                    'clip'?: number | string;
                    'clip-path'?: string;
                    'clipPathUnits'?: number | string;
                    'clip-rule'?: number | string;
                    'color-interpolation'?: number | string;
                    'color-interpolation-filters'?: 'auto' | 's-rGB' | 'linear-rGB' | 'inherit';
                    'color-profile'?: number | string;
                    'color-rendering'?: number | string;
                    'contentScriptType'?: number | string;
                    'contentStyleType'?: number | string;
                    'cursor'?: number | string;
                    'cx'?: number | string;
                    'cy'?: number | string;
                    'd'?: string;
                    'decelerate'?: number | string;
                    'descent'?: number | string;
                    'diffuseConstant'?: number | string;
                    'direction'?: number | string;
                    'display'?: number | string;
                    'divisor'?: number | string;
                    'dominant-baseline'?: number | string;
                    'dur'?: number | string;
                    'dx'?: number | string;
                    'dy'?: number | string;
                    'edge-mode'?: number | string;
                    'elevation'?: number | string;
                    'enable-background'?: number | string;
                    'end'?: number | string;
                    'exponent'?: number | string;
                    'externalResourcesRequired'?: number | string;
                    'fill'?: string;
                    'fill-opacity'?: number | string;
                    'fill-rule'?: 'nonzero' | 'evenodd' | 'inherit';
                    'filter'?: string;
                    'filterRes'?: number | string;
                    'filterUnits'?: number | string;
                    'flood-color'?: number | string;
                    'flood-opacity'?: number | string;
                    'focusable'?: number | string;
                    'font-family'?: string;
                    'font-size'?: number | string;
                    'font-size-adjust'?: number | string;
                    'font-stretch'?: number | string;
                    'font-style'?: number | string;
                    'font-variant'?: number | string;
                    'font-weight'?: number | string;
                    'format'?: number | string;
                    'from'?: number | string;
                    'fx'?: number | string;
                    'fy'?: number | string;
                    'g1'?: number | string;
                    'g2'?: number | string;
                    'glyph-name'?: number | string;
                    'glyph-orientation-horizontal'?: number | string;
                    'glyph-orientation-vertical'?: number | string;
                    'glyphRef'?: number | string;
                    'gradientTransform'?: string;
                    'gradientUnits'?: string;
                    'hanging'?: number | string;
                    'horiz-adv-x'?: number | string;
                    'horiz-origin-x'?: number | string;
                    'href'?: string;
                    'ideographic'?: number | string;
                    'image-rendering'?: number | string;
                    'in2'?: number | string;
                    'in'?: string;
                    'intercept'?: number | string;
                    'k1'?: number | string;
                    'k2'?: number | string;
                    'k3'?: number | string;
                    'k4'?: number | string;
                    'k'?: number | string;
                    'kernelMatrix'?: number | string;
                    'kernelUnitLength'?: number | string;
                    'kerning'?: number | string;
                    'keyPoints'?: number | string;
                    'keySplines'?: number | string;
                    'keyTimes'?: number | string;
                    'lengthAdjust'?: number | string;
                    'letter-spacing'?: number | string;
                    'lighting-color'?: number | string;
                    'limitingConeAngle'?: number | string;
                    'local'?: number | string;
                    'marker-end'?: string;
                    'markerHeight'?: number | string;
                    'marker-mid'?: string;
                    'marker-start'?: string;
                    'markerUnits'?: number | string;
                    'markerWidth'?: number | string;
                    'mask'?: string;
                    'maskContentUnits'?: number | string;
                    'maskUnits'?: number | string;
                    'mathematical'?: number | string;
                    'mode'?: number | string;
                    'numOctaves'?: number | string;
                    'offset'?: number | string;
                    'opacity'?: number | string;
                    'operator'?: number | string;
                    'order'?: number | string;
                    'orient'?: number | string;
                    'orientation'?: number | string;
                    'origin'?: number | string;
                    'overflow'?: number | string;
                    'overline-position'?: number | string;
                    'overline-thickness'?: number | string;
                    'paint-order'?: number | string;
                    'panose1'?: number | string;
                    'pathLength'?: number | string;
                    'patternContentUnits'?: string;
                    'patternTransform'?: number | string;
                    'patternUnits'?: string;
                    'pointer-events'?: number | string;
                    'points'?: string;
                    'pointsAtX'?: number | string;
                    'pointsAtY'?: number | string;
                    'pointsAtZ'?: number | string;
                    'preserveAlpha'?: number | string;
                    'preserveAspectRatio'?: string;
                    'primitiveUnits'?: number | string;
                    'r'?: number | string;
                    'radius'?: number | string;
                    'refX'?: number | string;
                    'refY'?: number | string;
                    'rendering-intent'?: number | string;
                    'repeatCount'?: number | string;
                    'repeatDur'?: number | string;
                    'requiredextensions'?: number | string;
                    'requiredFeatures'?: number | string;
                    'restart'?: number | string;
                    'result'?: string;
                    'rotate'?: number | string;
                    'rx'?: number | string;
                    'ry'?: number | string;
                    'scale'?: number | string;
                    'seed'?: number | string;
                    'shape-rendering'?: number | string;
                    'slope'?: number | string;
                    'spacing'?: number | string;
                    'specularConstant'?: number | string;
                    'specularExponent'?: number | string;
                    'speed'?: number | string;
                    'spreadMethod'?: string;
                    'startOffset'?: number | string;
                    'stdDeviation'?: number | string;
                    'stemh'?: number | string;
                    'stemv'?: number | string;
                    'stitchTiles'?: number | string;
                    'stop-color'?: string;
                    'stop-opacity'?: number | string;
                    'strikethrough-position'?: number | string;
                    'strikethrough-thickness'?: number | string;
                    'string'?: number | string;
                    'stroke'?: string;
                    'stroke-dasharray'?: string | number;
                    'stroke-dashoffset'?: string | number;
                    'stroke-linecap'?: 'butt' | 'round' | 'square' | 'inherit';
                    'stroke-linejoin'?: 'miter' | 'round' | 'bevel' | 'inherit';
                    'stroke-miterlimit'?: string;
                    'stroke-opacity'?: number | string;
                    'stroke-width'?: number | string;
                    'surfaceScale'?: number | string;
                    'systemLanguage'?: number | string;
                    'tableValues'?: number | string;
                    'targetX'?: number | string;
                    'targetY'?: number | string;
                    'text-anchor'?: string;
                    'text-decoration'?: number | string;
                    'textLength'?: number | string;
                    'text-rendering'?: number | string;
                    'to'?: number | string;
                    'transform'?: string;
                    'u1'?: number | string;
                    'u2'?: number | string;
                    'underline-position'?: number | string;
                    'underline-thickness'?: number | string;
                    'unicode'?: number | string;
                    'unicode-bidi'?: number | string;
                    'unicode-range'?: number | string;
                    'units-per-em'?: number | string;
                    'v-alphabetic'?: number | string;
                    'values'?: string;
                    'vector-effect'?: number | string;
                    'version'?: string;
                    'vert-adv-y'?: number | string;
                    'vert-origin-x'?: number | string;
                    'vert-origin-y'?: number | string;
                    'v-hanging'?: number | string;
                    'v-ideographic'?: number | string;
                    'viewBox'?: string;
                    'viewTarget'?: number | string;
                    'visibility'?: number | string;
                    'v-mathematical'?: number | string;
                    'widths'?: number | string;
                    'word-spacing'?: number | string;
                    'writing-mode'?: number | string;
                    'x1'?: number | string;
                    'x2'?: number | string;
                    'x'?: number | string;
                    'x-channel-selector'?: string;
                    'x-height'?: number | string;
                    'xlinkActuate'?: string;
                    'xlinkArcrole'?: string;
                    'xlinkHref'?: string;
                    'xlinkRole'?: string;
                    'xlinkShow'?: string;
                    'xlinkTitle'?: string;
                    'xlinkType'?: string;
                    'xmlBase'?: string;
                    'xmlLang'?: string;
                    'xmlns'?: string;
                    'xmlSpace'?: string;
                    'y1'?: number | string;
                    'y2'?: number | string;
                    'y'?: number | string;
                    'yChannelSelector'?: string;
                    'z'?: number | string;
                    'zoomAndPan'?: string;
            }
            interface DOMAttributes<T = Element> {
                    key?: string | number;
                    ref?: (elm?: T) => void;
                    slot?: string;
                    part?: string;
                    exportparts?: string;
                    onCopy?: (event: ClipboardEvent) => void;
                    onCopyCapture?: (event: ClipboardEvent) => void;
                    onCut?: (event: ClipboardEvent) => void;
                    onCutCapture?: (event: ClipboardEvent) => void;
                    onPaste?: (event: ClipboardEvent) => void;
                    onPasteCapture?: (event: ClipboardEvent) => void;
                    onCompositionEnd?: (event: CompositionEvent) => void;
                    onCompositionEndCapture?: (event: CompositionEvent) => void;
                    onCompositionStart?: (event: CompositionEvent) => void;
                    onCompositionStartCapture?: (event: CompositionEvent) => void;
                    onCompositionUpdate?: (event: CompositionEvent) => void;
                    onCompositionUpdateCapture?: (event: CompositionEvent) => void;
                    onFocus?: (event: FocusEvent) => void;
                    onFocusCapture?: (event: FocusEvent) => void;
                    onFocusin?: (event: FocusEvent) => void;
                    onFocusinCapture?: (event: FocusEvent) => void;
                    onFocusout?: (event: FocusEvent) => void;
                    onFocusoutCapture?: (event: FocusEvent) => void;
                    onBlur?: (event: FocusEvent) => void;
                    onBlurCapture?: (event: FocusEvent) => void;
                    onChange?: (event: Event) => void;
                    onChangeCapture?: (event: Event) => void;
                    onInput?: (event: Event) => void;
                    onInputCapture?: (event: Event) => void;
                    onReset?: (event: Event) => void;
                    onResetCapture?: (event: Event) => void;
                    onSubmit?: (event: Event) => void;
                    onSubmitCapture?: (event: Event) => void;
                    onInvalid?: (event: Event) => void;
                    onInvalidCapture?: (event: Event) => void;
                    onLoad?: (event: Event) => void;
                    onLoadCapture?: (event: Event) => void;
                    onError?: (event: Event) => void;
                    onErrorCapture?: (event: Event) => void;
                    onKeyDown?: (event: KeyboardEvent) => void;
                    onKeyDownCapture?: (event: KeyboardEvent) => void;
                    onKeyPress?: (event: KeyboardEvent) => void;
                    onKeyPressCapture?: (event: KeyboardEvent) => void;
                    onKeyUp?: (event: KeyboardEvent) => void;
                    onKeyUpCapture?: (event: KeyboardEvent) => void;
                    onAuxClick?: (event: MouseEvent) => void;
                    onClick?: (event: MouseEvent) => void;
                    onClickCapture?: (event: MouseEvent) => void;
                    onContextMenu?: (event: MouseEvent) => void;
                    onContextMenuCapture?: (event: MouseEvent) => void;
                    onDblClick?: (event: MouseEvent) => void;
                    onDblClickCapture?: (event: MouseEvent) => void;
                    onDrag?: (event: DragEvent) => void;
                    onDragCapture?: (event: DragEvent) => void;
                    onDragEnd?: (event: DragEvent) => void;
                    onDragEndCapture?: (event: DragEvent) => void;
                    onDragEnter?: (event: DragEvent) => void;
                    onDragEnterCapture?: (event: DragEvent) => void;
                    onDragExit?: (event: DragEvent) => void;
                    onDragExitCapture?: (event: DragEvent) => void;
                    onDragLeave?: (event: DragEvent) => void;
                    onDragLeaveCapture?: (event: DragEvent) => void;
                    onDragOver?: (event: DragEvent) => void;
                    onDragOverCapture?: (event: DragEvent) => void;
                    onDragStart?: (event: DragEvent) => void;
                    onDragStartCapture?: (event: DragEvent) => void;
                    onDrop?: (event: DragEvent) => void;
                    onDropCapture?: (event: DragEvent) => void;
                    onMouseDown?: (event: MouseEvent) => void;
                    onMouseDownCapture?: (event: MouseEvent) => void;
                    onMouseEnter?: (event: MouseEvent) => void;
                    onMouseLeave?: (event: MouseEvent) => void;
                    onMouseMove?: (event: MouseEvent) => void;
                    onMouseMoveCapture?: (event: MouseEvent) => void;
                    onMouseOut?: (event: MouseEvent) => void;
                    onMouseOutCapture?: (event: MouseEvent) => void;
                    onMouseOver?: (event: MouseEvent) => void;
                    onMouseOverCapture?: (event: MouseEvent) => void;
                    onMouseUp?: (event: MouseEvent) => void;
                    onMouseUpCapture?: (event: MouseEvent) => void;
                    onTouchCancel?: (event: TouchEvent) => void;
                    onTouchCancelCapture?: (event: TouchEvent) => void;
                    onTouchEnd?: (event: TouchEvent) => void;
                    onTouchEndCapture?: (event: TouchEvent) => void;
                    onTouchMove?: (event: TouchEvent) => void;
                    onTouchMoveCapture?: (event: TouchEvent) => void;
                    onTouchStart?: (event: TouchEvent) => void;
                    onTouchStartCapture?: (event: TouchEvent) => void;
                    onPointerDown?: (event: PointerEvent) => void;
                    onPointerDownCapture?: (event: PointerEvent) => void;
                    onPointerMove?: (event: PointerEvent) => void;
                    onPointerMoveCapture?: (event: PointerEvent) => void;
                    onPointerUp?: (event: PointerEvent) => void;
                    onPointerUpCapture?: (event: PointerEvent) => void;
                    onPointerCancel?: (event: PointerEvent) => void;
                    onPointerCancelCapture?: (event: PointerEvent) => void;
                    onPointerEnter?: (event: PointerEvent) => void;
                    onPointerEnterCapture?: (event: PointerEvent) => void;
                    onPointerLeave?: (event: PointerEvent) => void;
                    onPointerLeaveCapture?: (event: PointerEvent) => void;
                    onPointerOver?: (event: PointerEvent) => void;
                    onPointerOverCapture?: (event: PointerEvent) => void;
                    onPointerOut?: (event: PointerEvent) => void;
                    onPointerOutCapture?: (event: PointerEvent) => void;
                    onGotPointerCapture?: (event: PointerEvent) => void;
                    onGotPointerCaptureCapture?: (event: PointerEvent) => void;
                    onLostPointerCapture?: (event: PointerEvent) => void;
                    onLostPointerCaptureCapture?: (event: PointerEvent) => void;
                    onScroll?: (event: UIEvent) => void;
                    onScrollCapture?: (event: UIEvent) => void;
                    onWheel?: (event: WheelEvent) => void;
                    onWheelCapture?: (event: WheelEvent) => void;
                    onAnimationStart?: (event: AnimationEvent) => void;
                    onAnimationStartCapture?: (event: AnimationEvent) => void;
                    onAnimationEnd?: (event: AnimationEvent) => void;
                    onAnimationEndCapture?: (event: AnimationEvent) => void;
                    onAnimationIteration?: (event: AnimationEvent) => void;
                    onAnimationIterationCapture?: (event: AnimationEvent) => void;
                    onTransitionEnd?: (event: TransitionEvent) => void;
                    onTransitionEndCapture?: (event: TransitionEvent) => void;
            }
    }
    export interface CustomElementsDefineOptions {
            exclude?: string[];
            resourcesUrl?: string;
            syncQueue?: boolean;
            transformTagName?: (tagName: string) => string;
            jmp?: (c: Function) => any;
            raf?: (c: FrameRequestCallback) => number;
            ael?: (el: EventTarget, eventName: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions) => void;
            rel?: (el: EventTarget, eventName: string, listener: EventListenerOrEventListenerObject, options: boolean | AddEventListenerOptions) => void;
            ce?: (eventName: string, opts?: any) => CustomEvent;
    }
}

